{
  "version": 3,
  "sources": ["../../@daybrush/utils/src/consts.ts", "../../@daybrush/utils/src/utils.ts", "../../@daybrush/utils/src/color.ts", "../../@daybrush/utils/src/dom.ts", "../../@scena/event-emitter/src/EventEmitter.ts", "../../gesto/node_modules/tslib/tslib.es6.js", "../../gesto/src/utils.ts", "../../gesto/src/ClientStore.ts", "../../gesto/src/Gesto.ts", "../../framework-utils/src/index.ts", "../../@egjs/list-differ/src/PolyMap.ts", "../../@egjs/list-differ/src/HashMap.ts", "../../@egjs/list-differ/src/consts.ts", "../../@egjs/list-differ/src/Link.ts", "../../@egjs/list-differ/src/Result.ts", "../../@egjs/list-differ/src/utils.ts", "../../@egjs/list-differ/src/ListDiffer.ts", "../../@egjs/list-differ/src/index.ts", "../../@egjs/children-differ/src/consts.ts", "../../@egjs/children-differ/src/ChildrenDiffer.ts", "../../@egjs/children-differ/src/utils.ts", "../../@egjs/children-differ/src/index.ts", "../../@scena/dragscroll/src/DragScroll.ts", "../../keycon/src/utils.ts", "../../keycon/src/KeyController.ts", "../../keycon/src/reactive.ts", "../../overlap-area/src/utils.ts", "../../overlap-area/src/index.ts", "../../@scena/matrix/src/index.ts", "../../css-to-mat/node_modules/tslib/tslib.es6.js", "../../css-to-mat/src/CssToMatrix.ts", "../../css-styled/src/utils.ts", "../../css-styled/src/styled.ts", "../../selecto/src/utils.ts", "../../selecto/src/consts.ts", "../../selecto/src/SelectoManager.tsx", "../../selecto/src/Selecto.tsx", "../../react-selecto/src/react-selecto/consts.ts", "../../react-selecto/src/react-selecto/Selecto.tsx"],
  "sourcesContent": ["/**\n* @namespace\n* @name Consts\n*/\n\nimport { IObject, OpenCloseCharacter } from \"./types\";\n\n/**\n* get string \"rgb\"\n* @memberof Color\n* @example\nimport {RGB} from \"@daybrush/utils\";\n\nconsole.log(RGB); // \"rgb\"\n*/\nexport const RGB = \"rgb\";\n/**\n* get string \"rgba\"\n* @memberof Color\n* @example\nimport {RGBA} from \"@daybrush/utils\";\n\nconsole.log(RGBA); // \"rgba\"\n*/\nexport const RGBA = \"rgba\";\n/**\n* get string \"hsl\"\n* @memberof Color\n* @example\nimport {HSL} from \"@daybrush/utils\";\n\nconsole.log(HSL); // \"hsl\"\n*/\nexport const HSL = \"hsl\";\n/**\n* get string \"hsla\"\n* @memberof Color\n* @example\nimport {HSLA} from \"@daybrush/utils\";\n\nconsole.log(HSLA); // \"hsla\"\n*/\nexport const HSLA = \"hsla\";\n/**\n* gets an array of color models.\n* @memberof Color\n* @example\nimport {COLOR_MODELS} from \"@daybrush/utils\";\n\nconsole.log(COLOR_MODELS); // [\"rgb\", \"rgba\", \"hsl\", \"hsla\"];\n*/\nexport const COLOR_MODELS = [RGB, RGBA, HSL, HSLA];\n\n/**\n* get string \"function\"\n* @memberof Consts\n* @example\nimport {FUNCTION} from \"@daybrush/utils\";\n\nconsole.log(FUNCTION); // \"function\"\n*/\nexport const FUNCTION = \"function\";\n/**\n* get string \"property\"\n* @memberof Consts\n* @example\nimport {PROPERTY} from \"@daybrush/utils\";\n\nconsole.log(PROPERTY); // \"property\"\n*/\nexport const PROPERTY = \"property\";\n/**\n* get string \"array\"\n* @memberof Consts\n* @example\nimport {ARRAY} from \"@daybrush/utils\";\n\nconsole.log(ARRAY); // \"array\"\n*/\nexport const ARRAY = \"array\";\n/**\n* get string \"object\"\n* @memberof Consts\n* @example\nimport {OBJECT} from \"@daybrush/utils\";\n\nconsole.log(OBJECT); // \"object\"\n*/\nexport const OBJECT = \"object\";\n/**\n* get string \"string\"\n* @memberof Consts\n* @example\nimport {STRING} from \"@daybrush/utils\";\n\nconsole.log(STRING); // \"string\"\n*/\nexport const STRING = \"string\";\n/**\n* get string \"number\"\n* @memberof Consts\n* @example\nimport {NUMBER} from \"@daybrush/utils\";\n\nconsole.log(NUMBER); // \"number\"\n*/\nexport const NUMBER = \"number\";\n/**\n* get string \"undefined\"\n* @memberof Consts\n* @example\nimport {UNDEFINED} from \"@daybrush/utils\";\n\nconsole.log(UNDEFINED); // \"undefined\"\n*/\nexport const UNDEFINED = \"undefined\";\n\n/**\n* Check whether the environment is window or node.js.\n* @memberof Consts\n* @example\nimport {IS_WINDOW} from \"@daybrush/utils\";\n\nconsole.log(IS_WINDOW); // false in node.js\nconsole.log(IS_WINDOW); // true in browser\n*/\nexport const IS_WINDOW = typeof window !== UNDEFINED;\n\n/**\n* Check whether the environment is window or node.js.\n* @memberof Consts\n* @name document\n* @example\nimport {IS_WINDOW} from \"@daybrush/utils\";\n\nconsole.log(IS_WINDOW); // false in node.js\nconsole.log(IS_WINDOW); // true in browser\n*/\nconst doc = (typeof document !== UNDEFINED && document) as Document; // FIXME: this type maybe false\n\nexport {doc as document};\n\nconst prefixes: string[] = [\"webkit\", \"ms\", \"moz\", \"o\"];\n\n/**\n * @namespace CrossBrowser\n */\n\n/**\n* Get a CSS property with a vendor prefix that supports cross browser.\n* @function\n* @param {string} property - A CSS property\n* @return {string} CSS property with cross-browser vendor prefix\n* @memberof CrossBrowser\n* @example\nimport {getCrossBrowserProperty} from \"@daybrush/utils\";\n\nconsole.log(getCrossBrowserProperty(\"transform\")); // \"transform\", \"-ms-transform\", \"-webkit-transform\"\nconsole.log(getCrossBrowserProperty(\"filter\")); // \"filter\", \"-webkit-filter\"\n*/\nexport const getCrossBrowserProperty =  /*#__PURE__*/(property: string) => {\n  if (!doc) {\n    return \"\";\n  }\n  const styles = (doc.body || doc.documentElement).style as any;\n  const length = prefixes.length;\n\n  if (typeof styles[property] !== UNDEFINED) {\n    return property;\n  }\n  for (let i = 0; i < length; ++i) {\n    const name = `-${prefixes[i]}-${property}`;\n\n    if (typeof styles[name] !== UNDEFINED) {\n      return name;\n    }\n  }\n  return \"\";\n};\n\n/**\n* get string \"transfrom\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {TRANSFORM} from \"@daybrush/utils\";\n\nconsole.log(TRANSFORM); // \"transform\", \"-ms-transform\", \"-webkit-transform\"\n*/\nexport const TRANSFORM = /*#__PURE__*/getCrossBrowserProperty(\"transform\");\n/**\n* get string \"filter\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {FILTER} from \"@daybrush/utils\";\n\nconsole.log(FILTER); // \"filter\", \"-ms-filter\", \"-webkit-filter\"\n*/\nexport const FILTER = /*#__PURE__*/getCrossBrowserProperty(\"filter\");\n/**\n* get string \"animation\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {ANIMATION} from \"@daybrush/utils\";\n\nconsole.log(ANIMATION); // \"animation\", \"-ms-animation\", \"-webkit-animation\"\n*/\nexport const ANIMATION = /*#__PURE__*/getCrossBrowserProperty(\"animation\");\n/**\n* get string \"keyframes\" with the vendor prefix.\n* @memberof CrossBrowser\n* @example\nimport {KEYFRAMES} from \"@daybrush/utils\";\n\nconsole.log(KEYFRAMES); // \"keyframes\", \"-ms-keyframes\", \"-webkit-keyframes\"\n*/\nexport const KEYFRAMES = /*#__PURE__*/ANIMATION.replace(\"animation\", \"keyframes\");\n\nexport const OPEN_CLOSED_CHARACTERS: OpenCloseCharacter[] = [\n  { open: \"(\", close: \")\" },\n  { open: `\"`, close: `\"`},\n  { open: `'`, close: `'`},\n  { open: `\\\\\"`, close: `\\\\\"`},\n  { open: `\\\\'`, close: `\\\\'`},\n];\nexport const TINY_NUM = 0.0000001;\nexport const REVERSE_TINY_NUM = 1 / TINY_NUM;\nexport const DEFAULT_UNIT_PRESETS: IObject<(pos: number, size?: number) => number> = {\n  \"cm\": pos => pos * 96 / 2.54,\n  \"mm\": pos => pos * 96 / 254,\n  \"in\": pos => pos * 96,\n  \"pt\": pos => pos * 96 / 72,\n  \"pc\": pos => pos * 96 / 6,\n  \"%\": (pos, size) => pos * size! / 100,\n  \"vw\": (pos, size = window.innerWidth) => pos / 100 * size,\n  \"vh\": (pos, size = window.innerHeight) => pos / 100 * size,\n  \"vmax\": (pos, size = Math.max(window.innerWidth, window.innerHeight)) => pos / 100 * size,\n  \"vmin\": (pos, size = Math.min(window.innerWidth, window.innerHeight)) => pos / 100 * size,\n};\n", "import {\n  UNDEFINED, STRING,\n  OBJECT, FUNCTION,\n  IS_WINDOW, OPEN_CLOSED_CHARACTERS, NUMBER,\n  DEFAULT_UNIT_PRESETS,\n  TINY_NUM\n} from \"./consts\";\nimport {\n  FlattedElement,\n  IArrayFormat, IObject, OpenCloseCharacter,\n  SplitOptions,\n} from \"./types\";\n/**\n* @namespace\n* @name Utils\n*/\n\n/**\n * Returns the inner product of two numbers(`a1`, `a2`) by two criteria(`b1`, `b2`).\n * @memberof Utils\n * @param - The first number\n * @param - The second number\n * @param - The first number to base on the inner product\n * @param - The second number to base on the inner product\n * @return - Returns the inner product\nimport { dot } from \"@daybrush/utils\";\n\nconsole.log(dot(0, 15, 2, 3)); // 6\nconsole.log(dot(5, 15, 2, 3)); // 9\nconsole.log(dot(5, 15, 1, 1)); // 10\n */\nexport function dot(a1: number, a2: number, b1: number, b2: number) {\n  return (a1 * b2 + a2 * b1) / (b1 + b2);\n}\n/**\n* Check the type that the value is undefined.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {boolean} true if the type is correct, false otherwise\n* @example\nimport {isUndefined} from \"@daybrush/utils\";\n\nconsole.log(isUndefined(undefined)); // true\nconsole.log(isUndefined(\"\")); // false\nconsole.log(isUndefined(1)); // false\nconsole.log(isUndefined(null)); // false\n*/\nexport function isUndefined(value: any): value is undefined {\n  return (typeof value === UNDEFINED);\n}\n/**\n* Check the type that the value is object.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isObject} from \"@daybrush/utils\";\n\nconsole.log(isObject({})); // true\nconsole.log(isObject(undefined)); // false\nconsole.log(isObject(\"\")); // false\nconsole.log(isObject(null)); // false\n*/\nexport function isObject(value: any): value is IObject<any> {\n  return value && (typeof value === OBJECT);\n}\n/**\n* Check the type that the value is isArray.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isArray} from \"@daybrush/utils\";\n\nconsole.log(isArray([])); // true\nconsole.log(isArray({})); // false\nconsole.log(isArray(undefined)); // false\nconsole.log(isArray(null)); // false\n*/\nexport function isArray(value: any): value is any[] {\n  return Array.isArray(value);\n}\n/**\n* Check the type that the value is string.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isString} from \"@daybrush/utils\";\n\nconsole.log(isString(\"1234\")); // true\nconsole.log(isString(undefined)); // false\nconsole.log(isString(1)); // false\nconsole.log(isString(null)); // false\n*/\nexport function isString(value: any): value is string {\n  return typeof value === STRING;\n}\n\nexport function isNumber(value: any): value is number {\n  return typeof value === NUMBER;\n}\n\n/**\n* Check the type that the value is function.\n* @memberof Utils\n* @param {string} value - Value to check the type\n* @return {} true if the type is correct, false otherwise\n* @example\nimport {isFunction} from \"@daybrush/utils\";\n\nconsole.log(isFunction(function a() {})); // true\nconsole.log(isFunction(() => {})); // true\nconsole.log(isFunction(\"1234\")); // false\nconsole.log(isFunction(1)); // false\nconsole.log(isFunction(null)); // false\n*/\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === FUNCTION;\n}\nfunction isEqualSeparator(\n  character: string,\n  separator: string,\n) {\n  const isCharacterSpace = character === \"\" || character == \" \";\n  const isSeparatorSpace = separator === \"\" || separator == \" \";\n\n  return (isSeparatorSpace && isCharacterSpace) || character === separator;\n}\nfunction findOpen(\n  openCharacter: OpenCloseCharacter,\n  texts: string[],\n  index: number,\n  length: number,\n  openCloseCharacters: OpenCloseCharacter[],\n) {\n  const isIgnore = findIgnore(openCharacter, texts, index);\n\n  if (!isIgnore) {\n    return findClose(openCharacter, texts, index + 1, length, openCloseCharacters);\n  }\n  return index;\n}\nfunction findIgnore(\n  character: OpenCloseCharacter,\n  texts: string[],\n  index: number,\n) {\n  if (!character.ignore) {\n    return null;\n  }\n  const otherText = texts.slice(Math.max(index - 3, 0), index + 3).join(\"\");\n\n  return new RegExp(character.ignore).exec(otherText);\n\n}\nfunction findClose(\n  closeCharacter: OpenCloseCharacter,\n  texts: string[],\n  index: number,\n  length: number,\n  openCloseCharacters: OpenCloseCharacter[],\n) {\n  for (let i = index; i < length; ++i) {\n    const character = texts[i].trim();\n\n    if (character === closeCharacter.close && !findIgnore(closeCharacter, texts, i)) {\n      return i;\n    }\n    let nextIndex = i;\n    // re open\n    const openCharacter = find(openCloseCharacters, ({ open }) => open === character);\n\n    if (openCharacter) {\n      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);\n    }\n    if (nextIndex === -1) {\n      break;\n    }\n    i = nextIndex;\n  }\n  return -1;\n}\n\nexport function splitText(\n  text: string,\n  splitOptions: string | SplitOptions,\n): string[] {\n  const {\n    separator = \",\",\n    isSeparateFirst,\n    isSeparateOnlyOpenClose,\n    isSeparateOpenClose = isSeparateOnlyOpenClose,\n    openCloseCharacters = OPEN_CLOSED_CHARACTERS,\n  } = isString(splitOptions) ? {\n    separator: splitOptions,\n  } as SplitOptions : splitOptions;\n  const openClosedText = openCloseCharacters.map(({ open, close }) => {\n    if (open === close) {\n      return open;\n    }\n    return `${open}|${close}`;\n  }).join(\"|\");\n  const regexText = `(\\\\s*${separator}\\\\s*|${openClosedText}|\\\\s+)`;\n  const regex = new RegExp(regexText, \"g\");\n  const texts = text.split(regex).filter(chr => {\n    return chr && chr !== \"undefined\";\n  });\n  const length = texts.length;\n  const values: string[] = [];\n  let tempValues: string[] = [];\n\n  function resetTemp() {\n    if (tempValues.length) {\n      values.push(tempValues.join(\"\"));\n      tempValues = [];\n\n      return true;\n    }\n    return false;\n  }\n  for (let i = 0; i < length; ++i) {\n    const character = texts[i].trim();\n    let nextIndex = i;\n\n\n    const openCharacter = find(openCloseCharacters, ({ open }) => open === character);\n    const closeCharacter = find(openCloseCharacters, ({ close }) => close === character);\n\n    if (openCharacter) {\n      nextIndex = findOpen(openCharacter, texts, i, length, openCloseCharacters);\n\n      if (nextIndex !== -1 && isSeparateOpenClose) {\n        if (resetTemp() && isSeparateFirst) {\n          break;\n        }\n        values.push(texts.slice(i, nextIndex + 1).join(\"\"));\n        i = nextIndex;\n\n        if (isSeparateFirst) {\n          break;\n        }\n        continue;\n      }\n    } else if (closeCharacter && !findIgnore(closeCharacter, texts, i)) {\n      const nextOpenCloseCharacters = [...openCloseCharacters];\n\n      nextOpenCloseCharacters.splice(openCloseCharacters.indexOf(closeCharacter), 1);\n\n      return splitText(\n        text,\n        {\n          separator,\n          isSeparateFirst,\n          isSeparateOnlyOpenClose,\n          isSeparateOpenClose,\n          openCloseCharacters: nextOpenCloseCharacters,\n        });\n    } else if (isEqualSeparator(character, separator) && !isSeparateOnlyOpenClose) {\n      resetTemp();\n      if (isSeparateFirst) {\n        break;\n      }\n      continue;\n    }\n\n    if (nextIndex === -1) {\n      nextIndex = length - 1;\n    }\n    tempValues.push(texts.slice(i, nextIndex + 1).join(\"\"));\n    i = nextIndex;\n  }\n  if (tempValues.length) {\n    values.push(tempValues.join(\"\"));\n  }\n  return values;\n}\n\n/**\n* divide text by space.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {Array} divided texts\n* @example\nimport {spliceSpace} from \"@daybrush/utils\";\n\nconsole.log(splitSpace(\"a b c d e f g\"));\n// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\nconsole.log(splitSpace(\"'a,b' c 'd,e' f g\"));\n// [\"'a,b'\", \"c\", \"'d,e'\", \"f\", \"g\"]\n*/\nexport function splitSpace(text: string) {\n  // divide comma(space)\n  return splitText(text, \"\");\n}\n\n/**\n* divide text by comma.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {Array} divided texts\n* @example\nimport {splitComma} from \"@daybrush/utils\";\n\nconsole.log(splitComma(\"a,b,c,d,e,f,g\"));\n// [\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\"]\nconsole.log(splitComma(\"'a,b',c,'d,e',f,g\"));\n// [\"'a,b'\", \"c\", \"'d,e'\", \"f\", \"g\"]\n*/\nexport function splitComma(text: string): string[] {\n  // divide comma(,)\n  // \"[^\"]*\"|'[^']*'\n  return splitText(text, \",\");\n}\n/**\n* divide text by bracket \"(\", \")\".\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {object} divided texts\n* @example\nimport {splitBracket} from \"@daybrush/utils\";\n\nconsole.log(splitBracket(\"a(1, 2)\"));\n// {prefix: \"a\", value: \"1, 2\", suffix: \"\"}\nconsole.log(splitBracket(\"a(1, 2)b\"));\n// {prefix: \"a\", value: \"1, 2\", suffix: \"b\"}\n*/\nexport function splitBracket(text: string) {\n  const matches = (/([^(]*)\\(([\\s\\S]*)\\)([\\s\\S]*)/g).exec(text);\n\n  if (!matches || matches.length < 4) {\n    return {};\n  } else {\n    return { prefix: matches[1], value: matches[2], suffix: matches[3] };\n  }\n}\n/**\n* divide text by number and unit.\n* @memberof Utils\n* @param {string} text - text to divide\n* @return {} divided texts\n* @example\nimport {splitUnit} from \"@daybrush/utils\";\n\nconsole.log(splitUnit(\"10px\"));\n// {prefix: \"\", value: 10, unit: \"px\"}\nconsole.log(splitUnit(\"-10px\"));\n// {prefix: \"\", value: -10, unit: \"px\"}\nconsole.log(splitUnit(\"a10%\"));\n// {prefix: \"a\", value: 10, unit: \"%\"}\n*/\nexport function splitUnit(text: string): { prefix: string, unit: string, value: number } {\n  const matches = /^([^\\d|e|\\-|\\+]*)((?:\\d|\\.|-|e-|e\\+)+)(\\S*)$/g.exec(text);\n\n  if (!matches) {\n    return { prefix: \"\", unit: \"\", value: NaN };\n  }\n  const prefix = matches[1];\n  const value = matches[2];\n  const unit = matches[3];\n\n  return { prefix, unit, value: parseFloat(value) };\n}\n\n/**\n* transform strings to camel-case\n* @memberof Utils\n* @param {String} text - string\n* @return {String} camel-case string\n* @example\nimport {camelize} from \"@daybrush/utils\";\n\nconsole.log(camelize(\"transform-origin\")); // transformOrigin\nconsole.log(camelize(\"abcd_efg\")); // abcdEfg\nconsole.log(camelize(\"abcd efg\")); // abcdEfg\n*/\nexport function camelize(str: string) {\n  return str.replace(/[\\s-_]+([^\\s-_])/g, (all, letter) => letter.toUpperCase());\n}\n/**\n* transform a camelized string into a lowercased string.\n* @memberof Utils\n* @param {string} text - a camel-cased string\n* @param {string} [separator=\"-\"] - a separator\n* @return {string}  a lowercased string\n* @example\nimport {decamelize} from \"@daybrush/utils\";\n\nconsole.log(decamelize(\"transformOrigin\")); // transform-origin\nconsole.log(decamelize(\"abcdEfg\", \"_\")); // abcd_efg\n*/\nexport function decamelize(str: string, separator: string = \"-\") {\n  return str.replace(/([a-z])([A-Z])/g, (all, letter, letter2) => `${letter}${separator}${letter2.toLowerCase()}`);\n}\n\n/**\n* transforms something in an array into an array.\n* @memberof Utils\n* @param - Array form\n* @return an array\n* @example\nimport {toArray} from \"@daybrush/utils\";\n\nconst arr1 = toArray(document.querySelectorAll(\".a\")); // Element[]\nconst arr2 = toArray(document.querySelectorAll<HTMLElement>(\".a\")); // HTMLElement[]\n*/\nexport function toArray<T>(value: IArrayFormat<T>): T[] {\n  return [].slice.call(value);\n}\n\n/**\n* Date.now() method\n* @memberof CrossBrowser\n* @return {number} milliseconds\n* @example\nimport {now} from \"@daybrush/utils\";\n\nconsole.log(now()); // 12121324241(milliseconds)\n*/\nexport function now() {\n  return Date.now ? Date.now() : new Date().getTime();\n}\n\n/**\n* Returns the index of the first element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `findIndex` was called upon.\n* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.\n* @param - Returns defaultIndex if not found by the function.\n* @example\nimport { findIndex } from \"@daybrush/utils\";\n\nfindIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1\n*/\nexport function findIndex<T>(\n  arr: T[],\n  callback: (element: T, index: number, arr: T[]) => any,\n  defaultIndex: number = -1,\n): number {\n  const length = arr.length;\n\n  for (let i = 0; i < length; ++i) {\n    if (callback(arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return defaultIndex;\n}\n\n/**\n* Returns the reverse direction index of the first element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `findLastIndex` was called upon.\n* @param - A function to execute on each value in the array until the function returns true, indicating that the satisfying element was found.\n* @param - Returns defaultIndex if not found by the function.\n* @example\nimport { findLastIndex } from \"@daybrush/utils\";\n\nfindLastIndex([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // 1\n*/\nexport function findLastIndex<T>(\n  arr: T[],\n  callback: (element: T, index: number, arr: T[]) => any,\n  defaultIndex: number = -1,\n): number {\n  const length = arr.length;\n\n  for (let i = length - 1; i >= 0; --i) {\n    if (callback(arr[i], i, arr)) {\n      return i;\n    }\n  }\n  return defaultIndex;\n}\n\n/**\n* Returns the value of the reverse direction element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `findLast` was called upon.\n* @param - A function to execute on each value in the array,\n* @param - Returns defalutValue if not found by the function.\n* @example\nimport { find } from \"@daybrush/utils\";\n\nfind([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}\n*/\nexport function findLast<T>(\n  arr: T[],\n  callback: (element: T, index: number, arr: T[]) => any,\n  defalutValue?: T,\n): T | undefined {\n  const index = findLastIndex(arr, callback);\n\n  return index > - 1 ? arr[index] : defalutValue;\n}\n/**\n* Returns the value of the first element in the array that satisfies the provided testing function.\n* @function\n* @memberof CrossBrowser\n* @param - The array `find` was called upon.\n* @param - A function to execute on each value in the array,\n* @param - Returns defalutValue if not found by the function.\n* @example\nimport { find } from \"@daybrush/utils\";\n\nfind([{a: 1}, {a: 2}, {a: 3}, {a: 4}], ({ a }) => a === 2); // {a: 2}\n*/\nexport function find<T>(\n  arr: T[],\n  callback: (element: T, index: number, arr: T[]) => any,\n  defalutValue?: T,\n): T | undefined {\n  const index = findIndex(arr, callback);\n\n  return index > - 1 ? arr[index] : defalutValue;\n}\n\n/**\n* window.requestAnimationFrame() method with cross browser.\n* @function\n* @memberof CrossBrowser\n* @param {FrameRequestCallback} callback - The function to call when it's time to update your animation for the next repaint.\n* @return {number} id\n* @example\nimport {requestAnimationFrame} from \"@daybrush/utils\";\n\nrequestAnimationFrame((timestamp) => {\n  console.log(timestamp);\n});\n*/\nexport const requestAnimationFrame = /*#__PURE__*/(() => {\n  const firstTime = now();\n\n  const raf = IS_WINDOW\n    && (window.requestAnimationFrame || (window as any).webkitRequestAnimationFrame\n      || (window as any).mozRequestAnimationFrame || (window as any).msRequestAnimationFrame);\n\n  return raf ? (raf.bind(window) as (callback: FrameRequestCallback) => number) : ((callback: FrameRequestCallback) => {\n    const currTime = now();\n    const id = setTimeout(() => {\n      callback(currTime - firstTime);\n    }, 1000 / 60);\n\n    return id as any as number;\n  });\n})();\n\n/**\n* window.cancelAnimationFrame() method with cross browser.\n* @function\n* @memberof CrossBrowser\n* @param {number} handle - the id obtained through requestAnimationFrame method\n* @return {void}\n* @example\nimport { requestAnimationFrame, cancelAnimationFrame } from \"@daybrush/utils\";\n\nconst id = requestAnimationFrame((timestamp) => {\n  console.log(timestamp);\n});\n\ncancelAnimationFrame(id);\n*/\nexport const cancelAnimationFrame = /*#__PURE__*/(() => {\n  const caf = IS_WINDOW\n    && (window.cancelAnimationFrame || (window as any).webkitCancelAnimationFrame\n      || (window as any).mozCancelAnimationFrame || (window as any).msCancelAnimationFrame);\n\n  return caf\n    ? caf.bind(window) as (handle: number) => void\n    : ((handle: number) => { clearTimeout(handle); });\n})();\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function getKeys(obj: IObject<any>): string[] {\n  return Object.keys(obj);\n}\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function getValues(obj: IObject<any>): any[] {\n  const keys = getKeys(obj);\n\n  return keys.map(key => obj[key]);\n}\n/**\n* @function\n* @memberof Utils\n*/\nexport function getEntries(obj: IObject<any>): [string, any][] {\n  const keys = getKeys(obj);\n\n  return keys.map(key => [key, obj[key]]);\n}\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function sortOrders(keys: Array<string | number>, orders: Array<string | number> = []) {\n  keys.sort((a, b) => {\n    const index1 = orders.indexOf(a);\n    const index2 = orders.indexOf(b);\n\n    if (index2 === -1 && index1 === -1) {\n      return 0;\n    }\n    if (index1 === -1) {\n      return 1;\n    }\n    if (index2 === -1) {\n      return -1;\n    }\n    return index1 - index2;\n  });\n}\n\n/**\n* convert unit size to px size\n* @function\n* @memberof Utils\n*/\nexport function convertUnitSize(pos: string, size: number | IObject<((pos: number) => number) | number>) {\n  const { value, unit } = splitUnit(pos);\n\n  if (isObject(size)) {\n    const sizeFunction = size[unit];\n    if (sizeFunction) {\n      if (isFunction(sizeFunction)) {\n        return sizeFunction(value);\n      } else if (DEFAULT_UNIT_PRESETS[unit]) {\n        return DEFAULT_UNIT_PRESETS[unit](value, sizeFunction);\n      }\n    }\n  } else if (unit === \"%\") {\n    return value * size / 100;\n  }\n  if (DEFAULT_UNIT_PRESETS[unit]) {\n    return DEFAULT_UNIT_PRESETS[unit](value);\n  }\n  return value;\n}\n\n/**\n* calculate between min, max\n* @function\n* @memberof Utils\n*/\nexport function between(value: number, min: number, max: number): number {\n  return Math.max(min, Math.min(value, max));\n}\n\nexport function checkBoundSize(targetSize: number[], compareSize: number[], isMax: boolean, ratio = targetSize[0] / targetSize[1]) {\n  return [\n    [throttle(compareSize[0], TINY_NUM), throttle(compareSize[0] / ratio, TINY_NUM)],\n    [throttle(compareSize[1] * ratio, TINY_NUM), throttle(compareSize[1], TINY_NUM)],\n  ].filter(size => size.every((value, i) => {\n    const defaultSize = compareSize[i];\n    const throttledSize = throttle(defaultSize, TINY_NUM);\n\n    return isMax ? value <= defaultSize || value <= throttledSize : value >= defaultSize || value >= throttledSize;\n  }))[0] || targetSize;\n}\n\n/**\n* calculate bound size\n* @function\n* @memberof Utils\n*/\nexport function calculateBoundSize(\n  size: number[],\n  minSize: number[],\n  maxSize: number[],\n  keepRatio?: number | boolean,\n): number[] {\n  if (!keepRatio) {\n    return size.map((value, i) => between(value, minSize[i], maxSize[i]));\n  }\n  let [width, height] = size;\n\n  const ratio = keepRatio === true ? width / height : keepRatio;\n  // width : height = minWidth : minHeight;\n  const [minWidth, minHeight] = checkBoundSize(size, minSize, false, ratio);\n  const [maxWidth, maxHeight] = checkBoundSize(size, maxSize, true, ratio);\n\n  if (width < minWidth || height < minHeight) {\n    width = minWidth;\n    height = minHeight;\n  } else if (width > maxWidth || height > maxHeight) {\n    width = maxWidth;\n    height = maxHeight;\n  }\n  return [width, height];\n}\n\n\n/**\n* Add all the numbers.\n* @function\n* @memberof Utils\n*/\nexport function sum(nums: number[]): number {\n  const length = nums.length;\n  let total = 0;\n\n  for (let i = length - 1; i >= 0; --i) {\n    total += nums[i];\n  }\n  return total;\n}\n\n/**\n* Average all numbers.\n* @function\n* @memberof Utils\n*/\nexport function average(nums: number[]) {\n  const length = nums.length;\n  let total = 0;\n\n  for (let i = length - 1; i >= 0; --i) {\n    total += nums[i];\n  }\n  return length ? total / length : 0;\n}\n/**\n* Get the angle of two points. (0 <= rad < 359)\n* @function\n* @memberof Utils\n*/\nexport function getRad(pos1: number[], pos2: number[]): number {\n  const distX = pos2[0] - pos1[0];\n  const distY = pos2[1] - pos1[1];\n  const rad = Math.atan2(distY, distX);\n\n  return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n/**\n* Get the average point of all points.\n* @function\n* @memberof Utils\n*/\nexport function getCenterPoint(points: number[][]): number[] {\n  return [0, 1].map(i => average(points.map(pos => pos[i])));\n}\n/**\n* Gets the direction of the shape.\n* @function\n* @memberof Utils\n*/\nexport function getShapeDirection(points: number[][]): 1 | -1 {\n  const center = getCenterPoint(points);\n  const pos1Rad = getRad(center, points[0]);\n  const pos2Rad = getRad(center, points[1]);\n\n  return (pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI) || (pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI)\n    ? 1 : -1;\n}\n\n/**\n* Get the distance between two points.\n* @function\n* @memberof Utils\n*/\nexport function getDist(a: number[], b?: number[]) {\n  return Math.sqrt(Math.pow((b ? b[0] : 0) - a[0], 2) + Math.pow((b ? b[1] : 0) - a[1], 2));\n}\n\n/**\n* throttle number depending on the unit.\n* @function\n* @memberof Utils\n*/\nexport function throttle(num: number, unit?: number) {\n  if (!unit) {\n    return num;\n  }\n  const reverseUnit = 1 / unit;\n  return Math.round(num / unit) / reverseUnit;\n}\n\n/**\n* throttle number array depending on the unit.\n* @function\n* @memberof Utils\n*/\nexport function throttleArray(nums: number[], unit?: number) {\n  nums.forEach((_, i) => {\n    nums[i] = throttle(nums[i], unit);\n  });\n  return nums;\n}\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function counter(num: number): number[] {\n  const nums: number[] = [];\n\n  for (let i = 0; i < num; ++i) {\n    nums.push(i);\n  }\n\n  return nums;\n}\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function replaceOnce(text: string, fromText: RegExp | string, toText: string | ((...args: any[]) => string)): string {\n  let isOnce = false;\n  return text.replace(fromText, (...args: any[]) => {\n    if (isOnce) {\n      return args[0];\n    }\n    isOnce = true;\n    return isString(toText) ? toText : toText(...args);\n  });\n}\n\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function flat<Type>(arr: Type[][]): Type[] {\n  return arr.reduce((prev, cur) => {\n    return prev.concat(cur);\n  }, []);\n}\n\n/**\n* @function\n* @memberof Utils\n*/\nexport function deepFlat<T extends any[]>(arr: T): Array<FlattedElement<T[0]>> {\n  return arr.reduce((prev, cur) => {\n    if (isArray(cur)) {\n      prev.push(...deepFlat(cur));\n    } else {\n      prev.push(cur);\n    }\n    return prev;\n  }, [] as any[]);\n}\n\n\n/**\n * @function\n * @memberof Utils\n */\nexport function pushSet<T>(elements: T[], element: T) {\n  if (elements.indexOf(element) === -1) {\n    elements.push(element);\n  }\n}\n", "import { RGB, RGBA, HSL, HSLA } from \"./consts\";\nimport { splitBracket, splitComma } from \"./utils\";\n\n/**\n* @namespace\n* @name Color\n*/\n\n/**\n* Remove the # from the hex color.\n* @memberof Color\n* @param {} hex - hex color\n* @return {} hex color\n* @example\nimport {cutHex} from \"@daybrush/utils\";\n\nconsole.log(cutHex(\"#000000\")) // \"000000\"\n*/\nexport function cutHex(hex: string) {\n  return hex.replace(\"#\", \"\");\n}\n/**\n* convert hex color to rgb color.\n* @memberof Color\n* @param {} hex - hex color\n* @return {} rgb color\n* @example\nimport {hexToRGBA} from \"@daybrush/utils\";\n\nconsole.log(hexToRGBA(\"#00000005\"));\n// [0, 0, 0, 1]\nconsole.log(hexToRGBA(\"#201045\"));\n// [32, 16, 69, 1]\n*/\nexport function hexToRGBA(hex: string): [number, number, number, number] {\n  const h = cutHex(hex);\n  const r = parseInt(h.substring(0, 2), 16);\n  const g = parseInt(h.substring(2, 4), 16);\n  const b = parseInt(h.substring(4, 6), 16);\n  let a = parseInt(h.substring(6, 8), 16) / 255;\n\n  if (isNaN(a)) {\n    a = 1;\n  }\n  return [r, g, b, a];\n}\n\n/**\n* convert 3(or 4)-digit hex color to 6(or 8)-digit hex color.\n* @memberof Color\n* @param {} hex - 3(or 4)-digit hex color\n* @return {} 6(or 8)-digit hex color\n* @example\nimport {toFullHex} from \"@daybrush/utils\";\n\nconsole.log(toFullHex(\"#123\")); // \"#112233\"\nconsole.log(toFullHex(\"#123a\")); // \"#112233aa\"\n*/\nexport function toFullHex(h: string): string {\n  const r = h.charAt(1);\n  const g = h.charAt(2);\n  const b = h.charAt(3);\n  const a = h.charAt(4);\n  const arr = [\"#\", r, r, g, g, b, b, a, a];\n\n  return arr.join(\"\");\n}\n/**\n* convert hsl color to rgba color.\n* @memberof Color\n* @param {} hsl - hsl color(hue: 0 ~ 360, saturation: 0 ~ 1, lightness: 0 ~ 1, alpha: 0 ~ 1)\n* @return {} rgba color\n* @example\nimport {hslToRGBA} from \"@daybrush/utils\";\n\nconsole.log(hslToRGBA([150, 0.5, 0.4]));\n// [51, 153, 102, 1]\n*/\nexport function hslToRGBA(hsl: readonly [number, number, number, number?]): [number, number, number, number] {\n  let h = hsl[0];\n  const s = hsl[1];\n  const l = hsl[2];\n\n  if (h < 0) {\n    h +=  Math.floor((Math.abs(h) + 360) / 360) * 360;\n  }\n  h %= 360;\n\n  const c = (1 - Math.abs(2 * l - 1)) * s;\n  const x = c * (1 - Math.abs((h / 60) % 2 - 1));\n  const m = l - c / 2;\n  let rgb: [number, number, number];\n\n  if (h < 60) {\n    rgb = [c, x, 0];\n  } else if (h < 120) {\n    rgb = [x, c, 0];\n  } else if (h < 180) {\n    rgb = [0, c, x];\n  } else if (h < 240) {\n    rgb = [0, x, c];\n  } else if (h < 300) {\n    rgb = [x, 0, c];\n  } else if (h < 360) {\n    rgb = [c, 0, x];\n  } else {\n    rgb = [0, 0, 0];\n  }\n\n  return [\n    Math.round((rgb[0] + m) * 255),\n    Math.round((rgb[1] + m) * 255),\n    Math.round((rgb[2] + m) * 255),\n    hsl[3] ?? 1,\n  ];\n}\n/**\n* convert string to rgba color.\n* @memberof Color\n* @param {} - 3-hex(#000), 4-hex(#0000) 6-hex(#000000), 8-hex(#00000000) or RGB(A), or HSL(A)\n* @return {} rgba color\n* @example\nimport {stringToRGBA} from \"@daybrush/utils\";\n\nconsole.log(stringToRGBA(\"#000000\")); // [0, 0, 0, 1]\nconsole.log(stringToRGBA(\"rgb(100, 100, 100)\")); // [100, 100, 100, 1]\nconsole.log(stringToRGBA(\"hsl(150, 0.5, 0.4)\")); // [51, 153, 102, 1]\n*/\nexport function stringToRGBA(color: string): [number, number, number, number] {\n  if (color.charAt(0) === \"#\") {\n    if (color.length === 4 || color.length === 5) {\n      return hexToRGBA(toFullHex(color));\n    } else {\n      return hexToRGBA(color);\n    }\n  } else if (color.indexOf(\"(\") !== -1) {\n    // in bracket.\n    const {prefix, value} = splitBracket(color);\n\n    if (!prefix || !value) {\n      return undefined as never;\n    }\n    const arr = splitComma(value);\n    const colorArr: [number, number, number, number] = [0, 0, 0, 1];\n    const length = arr.length;\n\n    switch (prefix) {\n      case RGB:\n      case RGBA:\n        for (let i = 0; i < length; ++i) {\n          colorArr[i] = parseFloat(arr[i]);\n        }\n        return colorArr;\n      case HSL:\n      case HSLA:\n        for (let i = 0; i < length; ++i) {\n          if (arr[i].indexOf(\"%\") !== -1) {\n            colorArr[i] = parseFloat(arr[i]) / 100;\n          } else {\n            colorArr[i] = parseFloat(arr[i]);\n          }\n        }\n        // hsl, hsla to rgba\n        return hslToRGBA(colorArr);\n    }\n  }\n  return undefined as never;\n}\n", "import { document } from \"./consts\";\nimport { IObject, IEventMap } from \"./types\";\nimport { isObject } from \"./utils\";\n\n/**\n * @namespace DOM\n */\n\nexport function $<K extends keyof HTMLElementTagNameMap>(selectors: K, multi: true):\n  NodeListOf<HTMLElementTagNameMap[K]>;\nexport function $<K extends keyof SVGElementTagNameMap>(selectors: K, multi: true): NodeListOf<SVGElementTagNameMap[K]>;\nexport function $<E extends Element = Element>(selectors: string, multi: true): NodeListOf<E>;\n\nexport function $<K extends keyof HTMLElementTagNameMap>(selectors: K, multi?: false): HTMLElementTagNameMap[K] | null;\nexport function $<K extends keyof SVGElementTagNameMap>(selectors: K, multi?: false): SVGElementTagNameMap[K] | null;\nexport function $<E extends Element = Element>(selectors: string, multi?: false): E | null;\n/**\n * Returns all element descendants of node that\n * match selectors.\n */\n\n/**\n * Checks if the specified class value exists in the element's class attribute.\n * @memberof DOM\n * @param - A DOMString containing one or more selectors to match\n * @param - If multi is true, a DOMString containing one or more selectors to match against.\n * @example\nimport {$} from \"@daybrush/utils\";\n\nconsole.log($(\"div\")); // div element\nconsole.log($(\"div\", true)); // [div, div] elements\n*/\nexport function $<E extends Element = Element>(selectors: string, multi?: boolean): E | NodeListOf<E> | null {\n  if (!document) {\n    return multi ? [] as any : null;\n  }\n  return multi ? document.querySelectorAll<E>(selectors) : document.querySelector<E>(selectors);\n}\n\n/**\n* Checks if the specified class value exists in the element's class attribute.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to search\n* @return {boolean} return false if the class is not found.\n* @example\nimport {hasClass} from \"@daybrush/utils\";\n\nconsole.log(hasClass(element, \"start\")); // true or false\n*/\nexport function hasClass(element: Element, className: string) {\n  if (element.classList) {\n    return element.classList.contains(className);\n  }\n  return !!element.className.match(new RegExp(`(\\\\s|^)${className}(\\\\s|$)`));\n}\n\n/**\n* Add the specified class value. If these classe already exist in the element's class attribute they are ignored.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to add\n* @example\nimport {addClass} from \"@daybrush/utils\";\n\naddClass(element, \"start\");\n*/\nexport function addClass(element: Element, className: string) {\n  if (element.classList) {\n    element.classList.add(className);\n  } else {\n    element.className += ` ${className}`;\n  }\n}\n\n/**\n* Removes the specified class value.\n* @memberof DOM\n* @param element - target\n* @param className - the class name to remove\n* @example\nimport {removeClass} from \"@daybrush/utils\";\n\nremoveClass(element, \"start\");\n*/\nexport function removeClass(element: Element, className: string) {\n  if (element.classList) {\n    element.classList.remove(className);\n  } else {\n    const reg = new RegExp(`(\\\\s|^)${className}(\\\\s|$)`);\n\n    element.className = element.className.replace(reg, \" \");\n  }\n}\n\n/**\n* Gets the CSS properties from the element.\n* @memberof DOM\n* @param elements - elements\n* @param properites - the CSS properties\n* @return returns CSS properties and values.\n* @example\nimport {fromCSS} from \"@daybrush/utils\";\n\nconsole.log(fromCSS(element, [\"left\", \"opacity\", \"top\"])); // {\"left\": \"10px\", \"opacity\": 1, \"top\": \"10px\"}\n*/\nexport function fromCSS(\n  elements: Element | Element[] | NodeListOf<Element>, properties: string[]): IObject<any> {\n  if (!elements || !properties || !properties.length) {\n    return {};\n  }\n  let element;\n\n  if (elements instanceof Element) {\n    element = elements;\n  } else if (elements.length) {\n    element = elements[0];\n  } else {\n    return {};\n  }\n  const cssObject: IObject<any> = {};\n  const styles = getWindow(element).getComputedStyle(element) as any;\n  const length = properties.length;\n\n  for (let i = 0; i < length; ++i) {\n    cssObject[properties[i]] = styles[properties[i]];\n  }\n  return cssObject;\n}\n\nexport function addEvent<K extends keyof IEventMap>(\n  el: EventTarget, type: K, listener: (e: IEventMap[K]) => void, options?: boolean | AddEventListenerOptions): void;\n/**\n* Sets up a function that will be called whenever the specified event is delivered to the target\n* @memberof DOM\n* @param - event target\n* @param - A case-sensitive string representing the event type to listen for.\n* @param - The object which receives a notification (an object that implements the Event interface) when an event of the specified type occurs\n* @param - An options object that specifies characteristics about the event listener.\n* @example\nimport {addEvent} from \"@daybrush/utils\";\n\naddEvent(el, \"click\", e => {\n  console.log(e);\n});\n*/\nexport function addEvent(\n  el: EventTarget,\n  type: string, listener: (e: Event) => void,\n  options?: boolean | AddEventListenerOptions) {\n  el.addEventListener(type, listener, options);\n}\n\nexport function removeEvent<K extends keyof IEventMap>(\n  el: EventTarget, type: K, listener: (e: IEventMap[K]) => void, options?: boolean | EventListenerOptions): void;\n/**\n* removes from the EventTarget an event listener previously registered with EventTarget.addEventListener()\n* @memberof DOM\n* @param - event target\n* @param - A case-sensitive string representing the event type to listen for.\n* @param - The EventListener function of the event handler to remove from the event target.\n* @param - An options object that specifies characteristics about the event listener.\n* @example\nimport {addEvent, removeEvent} from \"@daybrush/utils\";\nconst listener = e => {\n  console.log(e);\n};\naddEvent(el, \"click\", listener);\nremoveEvent(el, \"click\", listener);\n*/\nexport function removeEvent(\n  el: EventTarget, type: string,\n  listener: (e: Event) => void,\n  options?: boolean | EventListenerOptions,\n) {\n  el.removeEventListener(type, listener, options);\n}\n\n\nexport function getDocument(el?: Node) {\n  return el?.ownerDocument || document;\n}\n\nexport function getDocumentElement(el?: Node) {\n  return getDocument(el).documentElement;\n}\n\nexport function getDocumentBody(el?: Node) {\n  return getDocument(el).body;\n}\n\nexport function getWindow(el?: Node) {\n  return el?.ownerDocument?.defaultView || window;\n}\n\n\nexport function isWindow(val: any): val is Window {\n  return val && \"postMessage\" in val && \"blur\" in val && \"self\" in val;\n}\n\nexport function isNode(el?: any): el is Node {\n  return isObject(el) && el.nodeName && el.nodeType && \"ownerDocument\" in el;\n}\n", "import { findIndex, isObject } from \"@daybrush/utils\";\nimport { EventListener, EventHash, EventInfo, EventOptions, OnEvent, TargetParam } from \"./types\";\n\n/**\n * Implement EventEmitter on object or component.\n */\nclass EventEmitter<Events extends {} = { [key: string]: { [key: string]: any } }> {\n\n    private _events: {\n        [name: string]: EventInfo[],\n    } = {};\n    public on<Name extends keyof Events, Param = Events[Name]>(\n        eventName: Name, listener: EventListener<Param, this>): this;\n    public on(events: EventHash<Events, this>): this;\n    /**\n     * Add a listener to the registered event.\n     * @param - Name of the event to be added\n     * @param - listener function of the event to be added\n     * @example\n     * import EventEmitter from \"@scena/event-emitter\";\n     * cosnt emitter = new EventEmitter();\n     *\n     * // Add listener in \"a\" event\n     * emitter.on(\"a\", () => {\n     * });\n     * // Add listeners\n     * emitter.on({\n     *  a: () => {},\n     *  b: () => {},\n     * });\n     */\n    public on(eventName: string | object, listener?: EventListener<Events[any], this>): this {\n        if (isObject(eventName)) {\n            for (const name in eventName) {\n                this.on<any>(name, eventName[name]);\n            }\n        } else {\n            this._addEvent(eventName, listener, {});\n        }\n        return this;\n    }\n    public off<Name extends keyof Events, Param = Events[Name]>(\n        eventName?: Name, listener?: EventListener<Param, this>): this;\n    public off(events: EventHash<Events, this>): this;\n    /**\n     * Remove listeners registered in the event target.\n     * @param - Name of the event to be removed\n     * @param - listener function of the event to be removed\n     * @example\n     * import EventEmitter from \"@scena/event-emitter\";\n     * cosnt emitter = new EventEmitter();\n     *\n     * // Remove all listeners.\n     * emitter.off();\n     *\n     * // Remove all listeners in \"A\" event.\n     * emitter.off(\"a\");\n     *\n     *\n     * // Remove \"listener\" listener in \"a\" event.\n     * emitter.off(\"a\", listener);\n     */\n    public off(eventName?: string | object, listener?: EventListener<Events[any], this>): this {\n        if (!eventName) {\n            this._events = {};\n        } else if(isObject(eventName)) {\n            for (const name in eventName) {\n                this.off<any>(name);\n            }\n        } else if (!listener) {\n            this._events[eventName] = [];\n        } else {\n            const events = this._events[eventName];\n\n            if (events) {\n                const index = findIndex(events, e => e.listener === listener);\n\n                if (index > -1) {\n                    events.splice(index, 1);\n                }\n            }\n        }\n        return this;\n    }\n    /**\n     * Add a disposable listener and Use promise to the registered event.\n     * @param - Name of the event to be added\n     * @param - disposable listener function of the event to be added\n     * @example\n     * import EventEmitter from \"@scena/event-emitter\";\n     * cosnt emitter = new EventEmitter();\n     *\n     * // Add a disposable listener in \"a\" event\n     * emitter.once(\"a\", () => {\n     * });\n     *\n     * // Use Promise\n     * emitter.once(\"a\").then(e => {\n     * });\n     */\n    public once<Name extends keyof Events & string, Param = Events[Name]>(\n        eventName: Name, listener?: EventListener<Param, this>): Promise<OnEvent<Param, this>> {\n        if (listener) {\n            this._addEvent(eventName, listener, { once: true });\n        }\n        return new Promise<OnEvent<Param, this>>(resolve => {\n            this._addEvent(eventName, resolve, { once: true });\n        });\n    }\n    public emit<Name extends keyof Events, Param = Events[Name]>(\n        eventName: {} extends Param ? Name : never): boolean;\n    public emit<Name extends keyof Events, Param = Events[Name]>(\n        eventName: Name, param: TargetParam<Param>): boolean;\n    /**\n     * Fires an event to call listeners.\n     * @param - Event name\n     * @param - Event parameter\n     * @return If false, stop the event.\n     * @example\n     *\n     * import EventEmitter from \"@scena/event-emitter\";\n     *\n     *\n     * const emitter = new EventEmitter();\n     *\n     * emitter.on(\"a\", e => {\n     * });\n     *\n     *\n     * emitter.emit(\"a\", {\n     *   a: 1,\n     * });\n     */\n    public emit(eventName: string, param: TargetParam<any> = {}): boolean {\n        const events = this._events[eventName];\n\n        if (!eventName || !events) {\n            return true;\n        }\n        let isStop = false;\n\n        param.eventType = eventName;\n        param.stop = () => {\n            isStop = true;\n        };\n        param.currentTarget = this;\n\n\n        [...events].forEach(info => {\n            info.listener(param);\n            if (info.once) {\n                this.off<any>(eventName, info.listener);\n            }\n        });\n\n        return !isStop;\n    }\n    public trigger<Name extends keyof Events, Param = Events[Name]>(eventName: {} extends TargetParam<Param> ? Name : never): boolean;\n    public trigger<Name extends keyof Events, Param = Events[Name]>(eventName: Name, param: TargetParam<Param>): boolean;\n    /**\n     * Fires an event to call listeners.\n     * @param - Event name\n     * @param - Event parameter\n     * @return If false, stop the event.\n     * @example\n     *\n     * import EventEmitter from \"@scena/event-emitter\";\n     *\n     *\n     * const emitter = new EventEmitter();\n     *\n     * emitter.on(\"a\", e => {\n     * });\n     *\n     *\n     * emitter.emit(\"a\", {\n     *   a: 1,\n     * });\n     *//**\n     * Fires an event to call listeners.\n     * @param - Event name\n     * @param - Event parameter\n     * @return If false, stop the event.\n     * @example\n     *\n     * import EventEmitter from \"@scena/event-emitter\";\n     *\n     *\n     * const emitter = new EventEmitter();\n     *\n     * emitter.on(\"a\", e => {\n     * });\n     *\n     * // emit\n     * emitter.trigger(\"a\", {\n     *   a: 1,\n     * });\n     */\n    public trigger<Name extends keyof Events>(eventName: Name, param: TargetParam<any>= {}): boolean {\n        return this.emit<any>(eventName, param);\n    }\n\n    private _addEvent(eventName: string, listener: EventListener<Events[any], this>, options: Partial<EventOptions>) {\n        const events = this._events;\n\n        events[eventName] = events[eventName] || [];\n\n        const listeners = events[eventName];\n\n        listeners.push({ listener, ...options });\n    }\n}\n\nexport default EventEmitter;\n", "/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __createBinding(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (p !== \"default\" && !exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n", "import { Client, Position } from \"./types\";\nimport { IArrayFormat, isNumber } from \"@daybrush/utils\";\n\nexport function getRad(pos1: number[], pos2: number[]) {\n    const distX = pos2[0] - pos1[0];\n    const distY = pos2[1] - pos1[1];\n    const rad = Math.atan2(distY, distX);\n\n    return rad >= 0 ? rad : rad + Math.PI * 2;\n}\n\nexport function getRotatiion(touches: Client[]) {\n    return getRad([\n        touches[0].clientX,\n        touches[0].clientY,\n    ], [\n        touches[1].clientX,\n        touches[1].clientY,\n    ]) / Math.PI * 180;\n}\n\nexport function isMultiTouch(e: any): e is TouchEvent {\n    return e.touches && e.touches.length >= 2;\n}\nexport function getEventClients(e: any): Client[] {\n    if (!e) {\n        return [];\n    } if (e.touches) {\n        return getClients(e.touches);\n    } else {\n        return [getClient(e)];\n    }\n}\nexport function isMouseEvent(e: any): e is MouseEvent {\n    return e && (e.type.indexOf(\"mouse\") > -1 || \"button\" in e);\n}\nexport function getPosition(clients: Client[], prevClients: Client[], startClients: Client[]): Position {\n    const length = startClients.length;\n    const {\n        clientX,\n        clientY,\n        originalClientX,\n        originalClientY,\n    } = getAverageClient(clients, length);\n    const {\n        clientX: prevX,\n        clientY: prevY,\n    } = getAverageClient(prevClients, length);\n\n    const {\n        clientX: startX,\n        clientY: startY,\n    } = getAverageClient(startClients, length);\n    const deltaX = clientX - prevX;\n    const deltaY = clientY - prevY;\n    const distX = clientX - startX;\n    const distY = clientY - startY;\n\n    return {\n        clientX: originalClientX!,\n        clientY: originalClientY!,\n        deltaX,\n        deltaY,\n        distX,\n        distY,\n    };\n}\nexport function getDist(clients: Client[]) {\n    return Math.sqrt(\n        Math.pow(clients[0].clientX - clients[1].clientX, 2)\n        + Math.pow(clients[0].clientY - clients[1].clientY, 2),\n    );\n}\nexport function getClients(touches: IArrayFormat<Touch>) {\n    const length = Math.min(touches.length, 2);\n    const clients = [];\n\n    for (let i = 0; i < length; ++i) {\n        clients.push(getClient(touches[i]));\n    }\n    return clients;\n}\nexport function getClient(e: MouseEvent | Touch): Client {\n    return {\n        clientX: e.clientX,\n        clientY: e.clientY,\n    };\n}\nexport function getAverageClient(clients: Client[], length = clients.length): Required<Client> {\n    const sumClient: Required<Client> = {\n        clientX: 0,\n        clientY: 0,\n        originalClientX: 0,\n        originalClientY: 0,\n    };\n    const minLength = Math.min(clients.length, length);\n\n    for (let i = 0; i < minLength; ++i) {\n        const client = clients[i];\n\n        sumClient.originalClientX += \"originalClientX\" in client ? client.originalClientX! : client.clientX;\n        sumClient.originalClientY += \"originalClientY\" in client ? client.originalClientY! : client.clientY;\n        sumClient.clientX += client.clientX;\n        sumClient.clientY += client.clientY;\n    }\n    if (!length) {\n        return sumClient;\n    }\n    return {\n        clientX: sumClient.clientX / length,\n        clientY: sumClient.clientY / length,\n        originalClientX: sumClient.originalClientX / length,\n        originalClientY: sumClient.originalClientY / length,\n    };\n}\nexport function plueClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX + client2.clientX),\n        clientY: (client1.clientY + client2.clientY),\n    };\n}\n\nexport function minusClient(client1: Client, client2: Client) {\n    return {\n        clientX: (client1.clientX - client2.clientX),\n        clientY: (client1.clientY - client2.clientY),\n    };\n}\n", "import { Client, Position } from \"./types\";\nimport { getPosition, getDist, getRotatiion, getAverageClient } from \"./utils\";\n\nexport class ClientStore {\n    public prevClients: Client[] = [];\n    public startClients: Client[] = [];\n    public movement = 0;\n    public length  = 0;\n    constructor(clients: Client[]) {\n        this.startClients = clients;\n        this.prevClients = clients;\n        this.length = clients.length;\n    }\n    public getAngle(clients: Client[] = this.prevClients) {\n        return getRotatiion(clients);\n    }\n    public getRotation(clients: Client[] = this.prevClients) {\n        return getRotatiion(clients) - getRotatiion(this.startClients);\n    }\n    public getPosition(clients: Client[] = this.prevClients, isAdd?: boolean) {\n        const position = getPosition(clients || this.prevClients, this.prevClients, this.startClients);\n\n        const { deltaX, deltaY } = position;\n\n        this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n        this.prevClients = clients;\n\n        return position;\n    }\n    public getPositions(clients: Client[] = this.prevClients) {\n        const prevClients = this.prevClients;\n        const startClients = this.startClients;\n        const minLength = Math.min(this.length, prevClients.length);\n        const positions: Position[] = [];\n\n        for (let i = 0; i < minLength; ++i) {\n            positions[i] = getPosition([clients[i]], [prevClients[i]], [startClients[i]]);\n        }\n\n        return positions;\n    }\n    public getMovement(clients?: Client[]) {\n        const movement = this.movement;\n\n        if (!clients) {\n            return movement;\n        }\n        const currentClient = getAverageClient(clients, this.length);\n        const prevClient = getAverageClient(this.prevClients, this.length);\n        const deltaX = currentClient.clientX - prevClient.clientX;\n        const deltaY = currentClient.clientY - prevClient.clientY;\n\n        return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;\n    }\n    public getDistance(clients = this.prevClients) {\n        return getDist(clients);\n    }\n    public getScale(clients = this.prevClients) {\n        return getDist(clients) / getDist(this.startClients);\n    }\n    public move(deltaX: number, deltaY: number) {\n        this.startClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n        this.prevClients.forEach(client => {\n            client.clientX -= deltaX;\n            client.clientY -= deltaY;\n        });\n    }\n}\n", "import { Client, OnDrag, GestoOptions, GestoEvents } from \"./types\";\nimport {\n    getEventClients, isMouseEvent, isMultiTouch,\n} from \"./utils\";\nimport EventEmitter, { TargetParam } from \"@scena/event-emitter\";\nimport { addEvent, removeEvent, now, IObject, getWindow, isWindow } from \"@daybrush/utils\";\nimport { ClientStore } from \"./ClientStore\";\n\nconst INPUT_TAGNAMES = [\"textarea\", \"input\"];\n/**\n * You can set up drag, pinch events in any browser.\n */\nclass Gesto extends EventEmitter<GestoEvents> {\n    public options: GestoOptions = {};\n\n    private flag = false;\n    private pinchFlag = false;\n    private data: IObject<any> = {};\n    private isDrag = false;\n    private isPinch = false;\n\n    private clientStores: ClientStore[] = [];\n    private targets: Array<Element | Window> = [];\n    private prevTime: number = 0;\n    private doubleFlag: boolean = false;\n    private _useMouse = false;\n    private _useTouch = false;\n    private _useDrag = false;\n    private _dragFlag = false;\n    private _isTrusted = false;\n    private _isMouseEvent = false;\n    private _isSecondaryButton = false;\n    private _preventMouseEvent = false;\n    private _prevInputEvent: any = null;\n    private _isDragAPI = false;\n    private _isIdle = true;\n    private _preventMouseEventId = 0;\n    private _window: WindowProxy = window;\n\n    /**\n     *\n     */\n    constructor(targets: Array<Element | Window> | Element | Window, options: GestoOptions = {}) {\n        super();\n        const elements = [].concat(targets as any) as Array<Element | Window>;\n        const firstTarget = elements[0];\n\n        this._window = isWindow(firstTarget) ? firstTarget : getWindow(firstTarget);\n        this.options = {\n            checkInput: false,\n            container: firstTarget && !(\"document\" in firstTarget)  ? getWindow(firstTarget) : firstTarget,\n            preventRightClick: true,\n            preventWheelClick: true,\n            preventClickEventOnDragStart: false,\n            preventClickEventOnDrag: false,\n            preventClickEventByCondition: null,\n            preventDefault: true,\n            checkWindowBlur: false,\n            keepDragging: false,\n            pinchThreshold: 0,\n            events: [\"touch\", \"mouse\"],\n            ...options,\n        };\n\n        const { container, events, checkWindowBlur } = this.options;\n\n        this._useDrag = events!.indexOf(\"drag\") > -1;\n        this._useTouch = events!.indexOf(\"touch\") > -1;\n        this._useMouse = events!.indexOf(\"mouse\") > -1;\n        this.targets = elements;\n\n        if (this._useDrag) {\n            elements.forEach(el => {\n                addEvent(el, \"dragstart\", this.onDragStart);\n            });\n        }\n        if (this._useMouse) {\n            elements.forEach(el => {\n                addEvent(el, \"mousedown\", this.onDragStart);\n                addEvent(el, \"mousemove\", this._passCallback);\n            });\n            addEvent(container!, \"contextmenu\", this._onContextMenu);\n        }\n        if (checkWindowBlur) {\n            addEvent(getWindow(), \"blur\", this.onBlur);\n        }\n        if (this._useTouch) {\n            const passive = {\n                passive: false,\n            };\n            elements.forEach(el => {\n                addEvent(el, \"touchstart\", this.onDragStart, passive);\n                addEvent(el, \"touchmove\", this._passCallback, passive);\n            });\n        }\n    }\n    /**\n     * Stop Gesto's drag events.\n     */\n    public stop() {\n        this.isDrag = false;\n        this.data = {};\n        this.clientStores = [];\n        this.pinchFlag = false;\n        this.doubleFlag = false;\n        this.prevTime = 0;\n        this.flag = false;\n        this._isIdle = true;\n\n        this._allowClickEvent();\n        this._dettachDragEvent();\n        this._isDragAPI = false;\n    }\n    /**\n     * The total moved distance\n     */\n    public getMovement(clients?: Client[]) {\n        return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce((prev, cur) => {\n            return prev + cur.movement;\n        }, 0);\n    }\n    /**\n     * Whether to drag\n     */\n    public isDragging(): boolean {\n        return this.isDrag;\n    }\n    /**\n     * Whether the operation of gesto is finished and is in idle state\n     */\n    public isIdle(): boolean {\n        return this._isIdle;\n    }\n    /**\n     * Whether to start drag\n     */\n    public isFlag(): boolean {\n        return this.flag;\n    }\n    /**\n     * Whether to start pinch\n     */\n    public isPinchFlag() {\n        return this.pinchFlag;\n    }\n    /**\n     * Whether to start double click\n     */\n    public isDoubleFlag() {\n        return this.doubleFlag;\n    }\n    /**\n     * Whether to pinch\n     */\n    public isPinching() {\n        return this.isPinch;\n    }\n\n    /**\n     * If a scroll event occurs, it is corrected by the scroll distance.\n     */\n    public scrollBy(deltaX: number, deltaY: number, e: any, isCallDrag: boolean = true) {\n        if (!this.flag) {\n            return;\n        }\n        this.clientStores[0].move(deltaX, deltaY);\n        isCallDrag && this.onDrag(e, true);\n    }\n    /**\n     * Create a virtual drag event.\n     */\n    public move([deltaX, deltaY]: number[], inputEvent: any): TargetParam<OnDrag> {\n        const store = this.getCurrentStore();\n        const nextClients = store.prevClients;\n\n        return this.moveClients(nextClients.map(({ clientX, clientY }) => {\n            return {\n                clientX: clientX + deltaX,\n                clientY: clientY + deltaY,\n                originalClientX: clientX,\n                originalClientY: clientY,\n            };\n        }), inputEvent, true);\n    }\n    /**\n     * The dragStart event is triggered by an external event.\n     */\n    public triggerDragStart(e: any) {\n        this.onDragStart(e, false);\n    }\n    /**\n     * Set the event data while dragging.\n     */\n    public setEventData(data: IObject<any>) {\n        const currentData = this.data;\n\n        for (const name in data) {\n            currentData[name] = data[name];\n        }\n        return this;\n    }\n    /**\n     * Set the event data while dragging.\n     * Use `setEventData`\n     * @deprecated\n     */\n    public setEventDatas(data: IObject<any>) {\n        return this.setEventData(data);\n    }\n    /**\n     * Get the current event state while dragging.\n     */\n    public getCurrentEvent(inputEvent: any = this._prevInputEvent) {\n        return {\n            data: this.data,\n            datas: this.data,\n            ...this._getPosition(),\n            movement: this.getMovement(),\n            isDrag: this.isDrag,\n            isPinch: this.isPinch,\n            isScroll: false,\n            inputEvent,\n        };\n    }\n    /**\n     * Get & Set the event data while dragging.\n     */\n    public getEventData() {\n        return this.data;\n    }\n    /**\n     * Get & Set the event data while dragging.\n     * Use getEventData method\n     * @depreacated\n     */\n    public getEventDatas() {\n        return this.data;\n    }\n    /**\n     * Unset Gesto\n     */\n    public unset() {\n        const targets = this.targets;\n        const container = this.options.container!;\n\n        this.off();\n        removeEvent(this._window, \"blur\", this.onBlur);\n\n        if (this._useDrag) {\n            targets.forEach(el => {\n                removeEvent(el, \"dragstart\", this.onDragStart);\n            });\n        }\n        if (this._useMouse) {\n            targets.forEach(target => {\n                removeEvent(target, \"mousedown\", this.onDragStart);\n            });\n            removeEvent(container, \"contextmenu\", this._onContextMenu);\n        }\n        if (this._useTouch) {\n            targets.forEach(target => {\n                removeEvent(target, \"touchstart\", this.onDragStart);\n            });\n            removeEvent(container, \"touchstart\", this.onDragStart);\n        }\n        this._prevInputEvent = null;\n        this._allowClickEvent();\n        this._dettachDragEvent();\n    }\n    public onDragStart = (e: any, isTrusted = true) => {\n        if (!this.flag && e.cancelable === false) {\n            return;\n        }\n        const isDragAPI = e.type.indexOf(\"drag\") >= -1;\n\n        if (this.flag && isDragAPI) {\n            return;\n        }\n\n        this._isDragAPI = true;\n        const {\n            container,\n            pinchOutside,\n            preventWheelClick,\n            preventRightClick,\n            preventDefault,\n            checkInput,\n            dragFocusedInput,\n            preventClickEventOnDragStart,\n            preventClickEventOnDrag,\n            preventClickEventByCondition,\n        } = this.options;\n        const useTouch = this._useTouch;\n        const isDragStart = !this.flag;\n\n        this._isSecondaryButton = e.which === 3 || e.button === 2;\n\n        if (\n            (preventWheelClick && (e.which === 2 || e.button === 1))\n            || (preventRightClick && (e.which === 3 || e.button === 2))\n        ) {\n            this.stop();\n            return false;\n        }\n\n        if (isDragStart) {\n            const activeElement = this._window.document.activeElement as HTMLElement;\n            const target = e.target as HTMLElement;\n\n            if (target) {\n                const tagName = target.tagName.toLowerCase();\n                const hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;\n                const hasContentEditable = target.isContentEditable;\n\n                if (hasInput || hasContentEditable) {\n                    if (checkInput || (!dragFocusedInput && activeElement === target)) {\n                        // force false or already focused.\n                        return false;\n                    }\n                    // no focus\n                    if (activeElement && (\n                        activeElement === target\n                        || (hasContentEditable && activeElement.isContentEditable && activeElement.contains(target))\n                    )) {\n                        if (dragFocusedInput) {\n                            target.blur();\n                        } else {\n                            return false;\n                        }\n                    }\n                } else if ((preventDefault || e.type === \"touchstart\") && activeElement) {\n                    const activeTagName = activeElement.tagName.toLowerCase();\n\n                    if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {\n                        activeElement.blur();\n                    }\n                }\n\n                if (preventClickEventOnDragStart || preventClickEventOnDrag || preventClickEventByCondition) {\n                    addEvent(this._window, \"click\", this._onClick, true);\n                }\n            }\n            this.clientStores = [new ClientStore(getEventClients(e))];\n            this._isIdle = false;\n            this.flag = true;\n            this.isDrag = false;\n            this._isTrusted = isTrusted;\n            this._dragFlag = true;\n            this._prevInputEvent = e;\n            this.data = {};\n\n            this.doubleFlag = now() - this.prevTime < 200;\n            this._isMouseEvent = isMouseEvent(e);\n            if (!this._isMouseEvent && this._preventMouseEvent) {\n                this._allowMouseEvent();\n            }\n\n            const result = this._preventMouseEvent || this.emit(\"dragStart\", {\n                data: this.data,\n                datas: this.data,\n                inputEvent: e,\n                isMouseEvent: this._isMouseEvent,\n                isSecondaryButton: this._isSecondaryButton,\n                isTrusted,\n                isDouble: this.doubleFlag,\n                ...this.getCurrentStore().getPosition(),\n                preventDefault() {\n                    e.preventDefault();\n                },\n                preventDrag: () => {\n                    this._dragFlag = false;\n                },\n            });\n            if (result === false) {\n                this.stop();\n            }\n            if (this._isMouseEvent && this.flag && preventDefault) {\n                e.preventDefault();\n            }\n        }\n        if (!this.flag) {\n            return false;\n        }\n        let timer = 0;\n\n        if (isDragStart) {\n            this._attchDragEvent();\n\n            // wait pinch\n            if (useTouch && pinchOutside) {\n                timer = setTimeout(() => {\n                    addEvent(container!, \"touchstart\", this.onDragStart, {\n                        passive: false\n                    });\n                });\n            }\n        } else if (useTouch && pinchOutside) {\n            // pinch is occured\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (this.flag && isMultiTouch(e)) {\n            clearTimeout(timer);\n            if (isDragStart && (e.touches.length !== e.changedTouches.length)) {\n                return;\n            }\n            if (!this.pinchFlag) {\n                this.onPinchStart(e);\n            }\n        }\n\n    }\n    public onDrag = (e: any, isScroll?: boolean) => {\n        if (!this.flag) {\n            return;\n        }\n        const {\n            preventDefault,\n        } = this.options;\n        if (!this._isMouseEvent && preventDefault) {\n            e.preventDefault();\n        }\n        this._prevInputEvent = e;\n        const clients = getEventClients(e);\n        const result = this.moveClients(clients, e, false);\n\n        if (this._dragFlag) {\n            if (this.pinchFlag || result.deltaX || result.deltaY) {\n                const dragResult = this._preventMouseEvent || this.emit(\"drag\", {\n                    ...result,\n                    isScroll: !!isScroll,\n                    inputEvent: e,\n                });\n\n                if (dragResult === false) {\n                    this.stop();\n                    return;\n                }\n            }\n            if (this.pinchFlag) {\n                this.onPinch(e, clients);\n            }\n        }\n\n        this.getCurrentStore().getPosition(clients, true);\n    }\n    public onDragEnd = (e?: any) => {\n        if (!this.flag) {\n            return;\n        }\n        const {\n            pinchOutside,\n            container,\n            preventClickEventOnDrag,\n            preventClickEventOnDragStart,\n            preventClickEventByCondition,\n        } = this.options;\n        const isDrag = this.isDrag;\n\n        if (preventClickEventOnDrag || preventClickEventOnDragStart || preventClickEventByCondition) {\n            requestAnimationFrame(() => {\n                this._allowClickEvent();\n            });\n        }\n        if (!preventClickEventByCondition && !preventClickEventOnDragStart && preventClickEventOnDrag && !isDrag) {\n            this._allowClickEvent();\n        }\n\n        if (this._useTouch && pinchOutside) {\n            removeEvent(container!, \"touchstart\", this.onDragStart);\n        }\n        if (this.pinchFlag) {\n            this.onPinchEnd(e);\n        }\n        const clients = e?.touches ? getEventClients(e) : [];\n        const clientsLength = clients.length;\n\n        if (clientsLength === 0 || !this.options.keepDragging) {\n            this.flag = false;\n        } else {\n            this._addStore(new ClientStore(clients));\n        }\n\n\n        const position = this._getPosition();\n        const currentTime = now();\n        const isDouble = !isDrag && this.doubleFlag;\n\n        this._prevInputEvent = null;\n        this.prevTime = isDrag || isDouble ? 0 : currentTime;\n\n        if (!this.flag) {\n            this._dettachDragEvent();\n\n            this._preventMouseEvent || this.emit(\"dragEnd\", {\n                data: this.data,\n                datas: this.data,\n                isDouble,\n                isDrag: isDrag,\n                isClick: !isDrag,\n                isMouseEvent: this._isMouseEvent,\n                isSecondaryButton: this._isSecondaryButton,\n                inputEvent: e,\n                isTrusted: this._isTrusted,\n                ...position,\n            });\n\n            this.clientStores = [];\n\n            if (!this._isMouseEvent) {\n                this._preventMouseEvent = true;\n\n                // Prevent the problem of touch event and mouse event occurring simultaneously\n                clearTimeout(this._preventMouseEventId);\n                this._preventMouseEventId = setTimeout(() => {\n                    this._preventMouseEvent = false;\n                }, 200);\n            }\n            this._isIdle = true;\n        }\n    }\n    public onPinchStart(e: TouchEvent) {\n        const { pinchThreshold } = this.options;\n\n        if (this.isDrag && this.getMovement() > pinchThreshold!) {\n            return;\n        }\n        const store = new ClientStore(getEventClients(e));\n\n        this.pinchFlag = true;\n        this._addStore(store);\n\n        const result = this.emit(\"pinchStart\", {\n            data: this.data,\n            datas: this.data,\n            angle: store.getAngle(),\n            touches: this.getCurrentStore().getPositions(),\n            ...store.getPosition(),\n            inputEvent: e,\n            isTrusted: this._isTrusted,\n            preventDefault() {\n                e.preventDefault();\n            },\n            preventDrag: () => {\n                this._dragFlag = false;\n            },\n        });\n\n        if (result === false) {\n            this.pinchFlag = false;\n        }\n    }\n    public onPinch(e: TouchEvent, clients: Client[]) {\n        if (!this.flag || !this.pinchFlag || clients.length < 2) {\n            return;\n        }\n\n        const store = this.getCurrentStore();\n        this.isPinch = true;\n\n        this.emit(\"pinch\", {\n            data: this.data,\n            datas: this.data,\n            movement: this.getMovement(clients),\n            angle: store.getAngle(clients),\n            rotation: store.getRotation(clients),\n            touches: store.getPositions(clients),\n            scale: store.getScale(clients),\n            distance: store.getDistance(clients),\n            ...store.getPosition(clients),\n            inputEvent: e,\n            isTrusted: this._isTrusted,\n        });\n    }\n    public onPinchEnd(e: TouchEvent) {\n        if (!this.pinchFlag) {\n            return;\n        }\n        const isPinch = this.isPinch;\n\n        this.isPinch = false;\n        this.pinchFlag = false;\n        const store = this.getCurrentStore();\n        this.emit(\"pinchEnd\", {\n            data: this.data,\n            datas: this.data,\n            isPinch,\n            touches: store.getPositions(),\n            ...store.getPosition(),\n            inputEvent: e,\n        });\n    }\n    private getCurrentStore() {\n        return this.clientStores[0];\n    }\n    private moveClients(clients: Client[], inputEvent: any, isAdd: boolean): TargetParam<OnDrag> {\n        const position = this._getPosition(clients, isAdd);\n\n        const isPrevDrag = this.isDrag;\n\n        if (position.deltaX || position.deltaY) {\n            this.isDrag = true;\n        }\n        let isFirstDrag = false;\n\n        if (!isPrevDrag && this.isDrag) {\n            isFirstDrag = true;\n        }\n\n        return {\n            data: this.data,\n            datas: this.data,\n            ...position,\n            movement: this.getMovement(clients),\n            isDrag: this.isDrag,\n            isPinch: this.isPinch,\n            isScroll: false,\n            isMouseEvent: this._isMouseEvent,\n            isSecondaryButton: this._isSecondaryButton,\n            inputEvent,\n            isTrusted: this._isTrusted,\n            isFirstDrag,\n        };\n    }\n    private onBlur = () => {\n        this.onDragEnd();\n    }\n    private _addStore(store: ClientStore) {\n        this.clientStores.splice(0, 0, store);\n    }\n    private _getPosition(clients?: Client[], isAdd?: boolean) {\n        const store = this.getCurrentStore();\n        const position = store.getPosition(clients, isAdd);\n\n        const { distX, distY } = this.clientStores.slice(1).reduce((prev, cur) => {\n            const storePosition = cur.getPosition();\n\n            prev.distX += storePosition.distX;\n            prev.distY += storePosition.distY;\n            return prev;\n        }, position);\n\n        return {\n            ...position,\n            distX,\n            distY,\n        };\n    }\n    private _allowClickEvent = () => {\n        removeEvent(this._window, \"click\", this._onClick, true);\n    };\n    private _attchDragEvent() {\n        const win = this._window;\n        const container = this.options.container!;\n        const passive = {\n            passive: false\n        };\n\n        if (this._isDragAPI) {\n            addEvent(container, \"dragover\", this.onDrag, passive);\n            addEvent(win, \"dragend\", this.onDragEnd);\n        }\n        if (this._useMouse) {\n            addEvent(container, \"mousemove\", this.onDrag);\n            addEvent(win, \"mouseup\", this.onDragEnd);\n        }\n\n        if (this._useTouch) {\n            addEvent(container, \"touchmove\", this.onDrag, passive);\n            addEvent(win, \"touchend\", this.onDragEnd, passive);\n            addEvent(win, \"touchcancel\", this.onDragEnd, passive);\n        }\n    };\n    private _dettachDragEvent() {\n        const win = this._window;\n        const container = this.options.container!;\n\n        if (this._isDragAPI) {\n            removeEvent(container, \"dragover\", this.onDrag);\n            removeEvent(win, \"dragend\", this.onDragEnd);\n        }\n        if (this._useMouse) {\n            removeEvent(container, \"mousemove\", this.onDrag);\n            removeEvent(win, \"mouseup\", this.onDragEnd);\n        }\n\n        if (this._useTouch) {\n            removeEvent(container, \"touchstart\", this.onDragStart);\n            removeEvent(container, \"touchmove\", this.onDrag);\n            removeEvent(win, \"touchend\", this.onDragEnd);\n            removeEvent(win, \"touchcancel\", this.onDragEnd);\n        }\n    };\n    private _onClick = (e: MouseEvent) => {\n        this._allowClickEvent();\n        this._allowMouseEvent();\n\n        const preventClickEventByCondition = this.options.preventClickEventByCondition;\n        if (preventClickEventByCondition?.(e)) {\n            return;\n        }\n        e.stopPropagation();\n        e.preventDefault();\n    }\n    private _onContextMenu = (e: MouseEvent) => {\n        const options = this.options;\n        if (!options.preventRightClick) {\n            e.preventDefault();\n        } else {\n            this.onDragEnd(e);\n        }\n    }\n    private _allowMouseEvent() {\n        this._preventMouseEvent = false;\n        clearTimeout(this._preventMouseEventId);\n    }\n    private _passCallback = () => { };\n}\n\nexport default Gesto;\n", "export function prefixNames(prefix: string, ...classNames: string[]) {\n    return classNames\n        .map((className) =>\n            className\n                .split(\" \")\n                .map((name) => (name ? `${prefix}${name}` : \"\"))\n                .join(\" \")\n        )\n        .join(\" \");\n}\n\nexport function prefixCSS(prefix: string, css: string) {\n    return css.replace(/([^}{]*){/gm, (_, selector) => {\n        return `${selector.replace(/\\.([^{,\\s\\d.]+)/g, `.${prefix}$1`)}{`;\n    });\n}\n\n/* react */\nexport function ref(target: any, name: string) {\n    return (e: any) => {\n        e && (target[name] = e);\n    };\n}\nexport function refs(target: any, name: string, i: number) {\n    return (e: any) => {\n        e && (target[name][i] = e);\n    };\n}\n\n/* Class Decorator */\nexport function Properties(\n    properties: any[],\n    action: (prototype: any, property: string) => any\n) {\n    return (component: any) => {\n        const prototype = component.prototype;\n\n        properties.forEach((property) => {\n            action(prototype, property);\n        });\n    };\n}\n\n/* Property Decorator */\nexport function withMethods(\n    methods: readonly string[],\n    duplicate: { [name: string]: string } = {}\n) {\n    return (prototype: any, propertyName: string) => {\n        methods.forEach((name) => {\n            const methodName = duplicate[name] || name;\n\n            if (methodName in prototype) {\n                return;\n            }\n            prototype[methodName] = function (...args) {\n                const result = this[propertyName][name](...args);\n\n                if (result === this[propertyName]) {\n                    return this;\n                } else {\n                    return result;\n                }\n            };\n        });\n    };\n}\n\nexport type ParametersType<Func, Return> = Func extends (\n    ...params: infer Params\n) => any\n    ? (...params: Params) => Return\n    : never;\n\nexport type ExcludeInterface<Obj1, Obj2> = {\n    [key in Exclude<keyof Obj1, keyof Obj2>]: Obj1[key];\n};\n\nexport type EntriesObject<T> = {\n    [key in keyof T]: [key, Readonly<T[key]>];\n};\nexport type FindKey<E, V> = E extends [infer U, V] ? U & string : never;\nexport type InvertObject<\n    T extends Record<string, any>,\n    En extends Record<string, any> = EntriesObject<T>\n    > = {\n        [key in En[keyof En][1]]: FindKey<En[keyof En], key>\n    };\n\nexport type Entries<\n    Obj extends { [key: string]: any },\n    Key = keyof Obj\n> = Key extends string ? [Key, Obj[Key]] : never;\n\nexport type ReverseKey<\n    Key extends string,\n    Obj extends { [key: string]: any },\n    E = Entries<Obj>\n> = E extends [infer Value, Key] ? Value : never;\n\nexport type UniqueMethodInterface<\n    Methods,\n    Target extends Methods,\n    ReturnTarget extends any,\n    Duplicate extends { [key: string]: any }\n> = {\n    [key in keyof ExcludeInterface<Methods, Duplicate>]: Methods[key] extends (\n        ...params: any[]\n    ) => Target\n        ? ParametersType<Methods[key], ReturnTarget>\n        : Methods[key];\n};\n\nexport type ChangedMethodInterface<\n    Methods,\n    Target extends Methods,\n    ReturnTarget extends any,\n    Duplicate extends { [key: string]: any }\n> = {\n    [key in Duplicate[keyof Duplicate]]: Methods[ReverseKey<key, Duplicate> &\n        keyof Methods] extends (...params: any[]) => Target\n        ? ParametersType<\n              Methods[ReverseKey<key, Duplicate> & keyof Methods],\n              ReturnTarget\n          >\n        : Methods[ReverseKey<key, Duplicate> & keyof Methods];\n};\n\nexport type MethodInterface<\n    Methods,\n    Target extends Methods,\n    ReturnTarget extends any,\n    Duplicate extends { [key: string]: any } = {}\n> = UniqueMethodInterface<Methods, Target, ReturnTarget, Duplicate> &\n    ChangedMethodInterface<Methods, Target, ReturnTarget, Duplicate>;\n", "/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport default class PolyMap<T> {\n  private keys: T[] = [];\n  private values: number[] = [];\n  public get(key: T): number {\n    return this.values[this.keys.indexOf(key)];\n  }\n  public set(key: T, value: number) {\n    const keys = this.keys;\n    const values = this.values;\n    const prevIndex = keys.indexOf(key);\n    const index = prevIndex === -1 ? keys.length : prevIndex;\n\n    keys[index] = key;\n    values[index] = value;\n  }\n}\n", "/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport default class HashMap<T> {\n  private object = {};\n  public get(key: number | string): T {\n    return this.object[key];\n  }\n  public set(key: number | string, value: T) {\n    this.object[key] = value;\n  }\n};\n\n", "/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport const SUPPORT_MAP = typeof Map === \"function\";\n", "/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport default class Link {\n  prev?: Link;\n  next?: Link;\n\n  public connect(prevLink?: Link, nextLink?: Link) {\n    this.prev = prevLink;\n    this.next = nextLink;\n\n    prevLink && (prevLink.next = this);\n    nextLink && (nextLink.prev = this);\n  }\n  public disconnect() {\n    // In double linked list, diconnect the interconnected relationship.\n    const prevLink = this.prev;\n    const nextLink = this.next;\n    prevLink && (prevLink.next = nextLink);\n    nextLink && (nextLink.prev = prevLink);\n  }\n  public getIndex() {\n    let link: Link | undefined = this;\n    let index = -1;\n\n    while (link) {\n      link = link.prev;\n      ++index;\n    }\n    return index;\n  }\n}\n", "/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport Link from \"./Link\";\n\nfunction orderChanged(changed: number[][], fixed: boolean[]) {\n  // It is roughly in the order of these examples.\n  // 4, 6, 0, 2, 1, 3, 5, 7\n  const fromLinks: Link[] = [];\n  // 0, 1, 2, 3, 4, 5, 6, 7\n  const toLinks: Link[] = [];\n\n  changed.forEach(([from, to]) => {\n    const link = new Link();\n\n    fromLinks[from] = link;\n    toLinks[to] = link;\n  });\n  // `fromLinks` are connected to each other by double linked list.\n  fromLinks.forEach((link, i) => {\n    link.connect(fromLinks[i - 1]);\n  });\n\n  return changed.filter((_, i) => !fixed[i]).map(([from, to], i) => {\n    if (from === to) {\n      return [0, 0];\n    }\n    const fromLink = fromLinks[from];\n    const toLink = toLinks[to - 1];\n    const fromIndex = fromLink.getIndex();\n\n    // Disconnect the link connected to `fromLink`.\n    fromLink.disconnect();\n\n    // Connect `fromLink` to the right of `toLink`.\n    if (!toLink) {\n      fromLink.connect(undefined, fromLinks[0]);\n    } else {\n      fromLink.connect(toLink, toLink.next);\n    }\n    const toIndex = fromLink.getIndex();\n    return [fromIndex, toIndex];\n  });\n}\n\nexport default class Result<T = any> {\n  public prevList: T[];\n  public list: T[];\n  public added: number[];\n  public removed: number[];\n  public changed: number[][];\n  public maintained: number[][];\n  private changedBeforeAdded: number[][];\n  private fixed: boolean[];\n\n  private cacheOrdered: number[][];\n  private cachePureChanged: number[][];\n  constructor(\n    prevList: T[],\n    list: T[],\n    added: number[],\n    removed: number[],\n    changed: number[][],\n    maintained: number[][],\n    changedBeforeAdded: number[][],\n    fixed: boolean[],\n  ) {\n    this.prevList = prevList;\n    this.list = list;\n    this.added = added;\n    this.removed = removed;\n    this.changed = changed;\n    this.maintained = maintained;\n    this.changedBeforeAdded = changedBeforeAdded;\n    this.fixed = fixed;\n  }\n  get ordered(): number[][] {\n    if (!this.cacheOrdered) {\n      this.caculateOrdered();\n    }\n    return this.cacheOrdered;\n  }\n  get pureChanged(): number[][] {\n    if (!this.cachePureChanged) {\n      this.caculateOrdered();\n    }\n    return this.cachePureChanged;\n  }\n  private caculateOrdered() {\n    const ordered = orderChanged(this.changedBeforeAdded, this.fixed);\n    const changed: number[][] = this.changed;\n    const pureChanged: number[][] = [];\n\n    this.cacheOrdered = ordered.filter(([from, to], i) => {\n      const [fromBefore, toBefore] = changed[i];\n\n      if (from !== to) {\n        pureChanged.push([fromBefore, toBefore]);\n        return true;\n      }\n    });\n    this.cachePureChanged = pureChanged;\n  }\n}\n", "/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport { MapInteface, DiffResult } from \"./types\";\nimport PolyMap from \"./PolyMap\";\nimport HashMap from \"./HashMap\";\nimport { SUPPORT_MAP } from \"./consts\";\nimport Result from \"./Result\";\n\n/**\n *\n * @memberof eg.ListDiffer\n * @static\n * @function\n * @param - Previous List <ko>   </ko>\n * @param - List to Update <ko>    </ko>\n * @param - This callback function returns the key of the item. <ko>     .</ko>\n * @return - Returns the diff between `prevList` and `list` <ko> `prevList` `list`   .</ko>\n * @example\n * import { diff } from \"@egjs/list-differ\";\n * // script => eg.ListDiffer.diff\n * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1], e => e);\n * // List before update\n * // [1, 2, 3, 4, 5]\n * console.log(result.prevList);\n * // Updated list\n * // [4, 3, 6, 2, 1]\n * console.log(result.list);\n * // Index array of values added to `list`\n * // [0, 1, 5]\n * console.log(result.added);\n * // Index array of values removed in `prevList`\n * // [5]\n * console.log(result.removed);\n * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.changed);\n * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n * // [[4, 3], [3, 4], [2, 6]]\n * console.log(result.pureChanged);\n * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n * // [[4, 1], [4, 2], [4, 3]]\n * console.log(result.ordered);\n * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.maintained);\n */\nexport function diff<T>(\n  prevList: T[],\n  list: T[],\n  findKeyCallback?: (e: T, i: number, arr: T[]) => any\n): DiffResult<T> {\n  const mapClass: new () => MapInteface<any, number> = SUPPORT_MAP ? Map : (findKeyCallback ? HashMap : PolyMap);\n  const callback = findKeyCallback || ((e: T) => e);\n  const added: number[] = [];\n  const removed: number[] = [];\n  const maintained: number[][] = [];\n  const prevKeys = prevList.map(callback);\n  const keys = list.map(callback);\n  const prevKeyMap: MapInteface<any, number> = new mapClass();\n  const keyMap: MapInteface<any, number> = new mapClass();\n  const changedBeforeAdded: number[][] = [];\n  const fixed: boolean[] = [];\n  const removedMap: object = {};\n  let changed: number[][] = [];\n  let addedCount = 0;\n  let removedCount = 0;\n\n  // Add prevKeys and keys to the hashmap.\n  prevKeys.forEach((key, prevListIndex) => {\n    prevKeyMap.set(key, prevListIndex);\n  });\n  keys.forEach((key, listIndex) => {\n    keyMap.set(key, listIndex);\n  });\n\n  // Compare `prevKeys` and `keys` and add them to `removed` if they are not in `keys`.\n  prevKeys.forEach((key, prevListIndex) => {\n    const listIndex = keyMap.get(key);\n\n    // In prevList, but not in list, it is removed.\n    if (typeof listIndex === \"undefined\") {\n      ++removedCount;\n      removed.push(prevListIndex);\n    } else {\n      removedMap[listIndex] = removedCount;\n    }\n  });\n\n  // Compare `prevKeys` and `keys` and add them to `added` if they are not in `prevKeys`.\n  keys.forEach((key, listIndex) => {\n    const prevListIndex = prevKeyMap.get(key);\n\n    // In list, but not in prevList, it is added.\n    if (typeof prevListIndex === \"undefined\") {\n      added.push(listIndex);\n      ++addedCount;\n    } else {\n      maintained.push([prevListIndex, listIndex]);\n      removedCount = removedMap[listIndex] || 0;\n\n      changedBeforeAdded.push([\n        prevListIndex - removedCount,\n        listIndex - addedCount,\n      ]);\n      fixed.push(listIndex === prevListIndex);\n      if (prevListIndex !== listIndex) {\n        changed.push([prevListIndex, listIndex]);\n      }\n    }\n  });\n  // Sort by ascending order of 'to(list's index).\n  removed.reverse();\n\n  return new Result(\n    prevList,\n    list,\n    added,\n    removed,\n    changed,\n    maintained,\n    changedBeforeAdded,\n    fixed,\n  );\n}\n", "/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport { DiffResult, ListFormat } from \"./types\";\nimport { diff } from \"./utils\";\n\n/**\n * A module that checks diff when values are added, removed, or changed in an array.\n * @ko          .\n * @memberof eg\n */\nclass ListDiffer<T> {\n  private list: T[];\n  /**\n   * @param - Initializing Data Array. <ko>    .</ko>\n   * @param - This callback function returns the key of the item. <ko>     .</ko>\n   * @example\n   * import ListDiffer from \"@egjs/list-differ\";\n   * // script => eg.ListDiffer\n   * const differ = new ListDiffer([0, 1, 2, 3, 4, 5], e => e);\n   * const result = differ.update([7, 8, 0, 4, 3, 6, 2, 1]);\n   * // List before update\n   * // [1, 2, 3, 4, 5]\n   * console.log(result.prevList);\n   * // Updated list\n   * // [4, 3, 6, 2, 1]\n   * console.log(result.list);\n   * // Index array of values added to `list`.\n   * // [0, 1, 5]\n   * console.log(result.added);\n   * // Index array of values removed in `prevList`.\n   * // [5]\n   * console.log(result.removed);\n   * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.changed);\n   * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n   * // [[4, 3], [3, 4], [2, 6]]\n   * console.log(result.pureChanged);\n   * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n   * // [[4, 1], [4, 2], [4, 3]]\n   * console.log(result.ordered);\n   * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved.\n   * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n   * console.log(result.maintained);\n   */\n  constructor(\n    list: ListFormat<T> = [],\n    private findKeyCallback?: (e: T, i: number, arr: T[]) => number | string,\n  ) {\n    this.list = [].slice.call(list);\n  }\n  /**\n   * Update list.\n   * @ko   .\n   * @param - List to update <ko>   </ko>\n   * @return - Returns the results of an update from `prevList` to `list`.<ko> `prevList` `list`   . </ko>\n   */\n  public update(list: ListFormat<T>): DiffResult<T> {\n    const newData: T[] = [].slice.call(list);\n    const result = diff<T>(this.list, newData, this.findKeyCallback);\n\n    this.list = newData;\n    return result;\n  }\n}\n\nexport default ListDiffer;\n", "/*\negjs-list-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport ListDiffer from \"./ListDiffer\";\nexport default ListDiffer;\nexport { diff } from \"./utils\";\nexport * from \"./types\";\n", "/*\negjs-children-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nexport const findKeyCallback = typeof Map === \"function\"\n  ? undefined\n  : (() => {\n    let childrenCount = 0;\n\n    return (el: Element) => (el as any).__DIFF_KEY__ || ((el as any).__DIFF_KEY__ = ++childrenCount);\n  })();\n", "/*\negjs-children-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport ListDiffer, { ListFormat } from \"@egjs/list-differ\";\nimport { findKeyCallback } from \"./consts\";\n\n/**\n * A module that checks diff when child are added, removed, or changed .\n * @ko           .\n * @memberof eg\n * @extends eg.ListDiffer\n */\nclass ChildrenDiffer<T extends Element = Element> extends ListDiffer<T> {\n  /**\n   * @param - Initializing Children <ko>    </ko>\n   */\n  constructor(\n    list: ListFormat<T> = [],\n  ) {\n    super(list, findKeyCallback);\n  }\n}\nexport default ChildrenDiffer;\n", "/*\negjs-children-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport {diff as listdiff} from \"@egjs/list-differ\";\nimport { findKeyCallback } from \"./consts\";\nimport { ChildrenDiffResult } from \"./types\";\n\n\n/**\n *\n * @memberof eg.ChildrenDiffer\n * @static\n * @function\n * @param - Previous List <ko>   </ko>\n * @param - List to Update <ko>    </ko>\n * @return - Returns the diff between `prevList` and `list` <ko> `prevList` `list`   .</ko>\n * @example\n * import { diff } from \"@egjs/children-differ\";\n * // script => eg.ChildrenDiffer.diff\n * const result = diff([0, 1, 2, 3, 4, 5], [7, 8, 0, 4, 3, 6, 2, 1]);\n * // List before update\n * // [1, 2, 3, 4, 5]\n * console.log(result.prevList);\n * // Updated list\n * // [4, 3, 6, 2, 1]\n * console.log(result.list);\n * // Index array of values added to `list`\n * // [0, 1, 5]\n * console.log(result.added);\n * // Index array of values removed in `prevList`\n * // [5]\n * console.log(result.removed);\n * // An array of index pairs of `prevList` and `list` with different indexes from `prevList` and `list`\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.changed);\n * // The subset of `changed` and an array of index pairs that moved data directly. Indicate an array of absolute index pairs of `ordered`.(Formatted by: Array<[index of prevList, index of list]>)\n * // [[4, 3], [3, 4], [2, 6]]\n * console.log(result.pureChanged);\n * // An array of index pairs to be `ordered` that can synchronize `list` before adding data. (Formatted by: Array<[prevIndex, nextIndex]>)\n * // [[4, 1], [4, 2], [4, 3]]\n * console.log(result.ordered);\n * // An array of index pairs of `prevList` and `list` that have not been added/removed so data is preserved\n * // [[0, 2], [4, 3], [3, 4], [2, 6], [1, 7]]\n * console.log(result.maintained);\n */\nexport function diff<T extends Element = Element>(\n  prevList: T[],\n  list: T[],\n): ChildrenDiffResult<T> {\n  return listdiff<T>(prevList, list, findKeyCallback);\n}\n", "/*\negjs-children-differ\nCopyright (c) 2019-present NAVER Corp.\nMIT license\n*/\nimport ChildrenDiffer from \"./ChildrenDiffer\";\nexport default ChildrenDiffer;\nexport { diff } from \"./utils\";\nexport * from \"./types\";\n", "import EventEmitter from \"@scena/event-emitter\";\nimport { isFunction, isString, now } from \"@daybrush/utils\";\nimport { CheckScrollOptions, DragScrollEvents, DragScrollOptions, Rect } from \"./types\";\n\nfunction getDefaultScrollPosition(e: { container: HTMLElement, direction: number[] }) {\n    let container = e.container;\n\n    if (container === document.body) {\n        return [\n            container.scrollLeft || document.documentElement.scrollLeft,\n            container.scrollTop || document.documentElement.scrollTop,\n        ];\n    }\n    return [\n        container.scrollLeft,\n        container.scrollTop,\n    ];\n}\n\nfunction checkDefaultScrollEvent(container: HTMLElement | Window, callback: () => void) {\n    container.addEventListener(\"scroll\", callback);\n\n    return () => {\n        container.removeEventListener(\"scroll\", callback);\n    }\n}\n\nfunction getContainerElement(container: DragScrollOptions[\"container\"]): HTMLElement {\n    if (!container) {\n        return null;\n    } else if (isString(container)) {\n        return document.querySelector<HTMLElement>(container);\n    } if (isFunction(container)) {\n        return container();\n    } else if (container instanceof Element) {\n        return container;\n    } else if (\"current\" in container) {\n        return container.current;\n    } else if (\"value\" in container) {\n        return container.value;\n    }\n}\n\n/**\n * @sort 1\n */\nclass DragScroll extends EventEmitter<DragScrollEvents> {\n    private _startRect: Rect | null = null;\n    private _startPos: number[] = [];\n    private _prevTime: number = 0;\n    private _timer: number = 0;\n    private _prevScrollPos: number[] = [0, 0];\n    private _isWait = false;\n    private _flag = false;\n    private _currentOptions: DragScrollOptions | null = null;\n    private _lock = false;\n    private _unregister: (() => void) | null = null;\n    /**\n     */\n    public dragStart(e: any, options: DragScrollOptions) {\n        const container = getContainerElement(options.container);\n\n        if (!container) {\n            this._flag = false;\n            return;\n        }\n        let top = 0;\n        let left = 0;\n        let width = 0;\n        let height = 0;\n\n        if (container === document.body) {\n            width = window.innerWidth;\n            height = window.innerHeight;\n        } else {\n            const rect = container.getBoundingClientRect();\n\n            top = rect.top;\n            left = rect.left;\n            width = rect.width;\n            height = rect.height;\n        }\n\n        this._flag = true;\n        this._startPos = [e.clientX, e.clientY];\n        this._startRect = { top, left, width, height };\n        this._prevScrollPos = this._getScrollPosition([0, 0], options);\n        this._currentOptions = options;\n        this._registerScrollEvent(options);\n    }\n    public drag(e: any, options: DragScrollOptions) {\n        clearTimeout(this._timer);\n        if (!this._flag) {\n            return;\n        }\n        const {\n            clientX,\n            clientY,\n        } = e;\n        const {\n            threshold = 0,\n        } = options;\n        const {\n            _startRect,\n            _startPos,\n        } = this;\n\n\n        this._currentOptions = options;\n        const direction = [0, 0];\n\n        if (_startRect.top > clientY - threshold) {\n            if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {\n                direction[1] = -1;\n            }\n        } else if (_startRect.top + _startRect.height < clientY + threshold) {\n            if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {\n                direction[1] = 1;\n            }\n        }\n        if (_startRect.left > clientX - threshold) {\n            if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {\n                direction[0] = -1;\n            }\n        } else if (_startRect.left + _startRect.width < clientX + threshold) {\n            if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {\n                direction[0] = 1;\n            }\n        }\n\n        if (!direction[0] && !direction[1]) {\n            return false;\n        }\n        return this._continueDrag({\n            ...options,\n            direction,\n            inputEvent: e,\n            isDrag: true,\n        });\n    }\n    /**\n     */\n    public checkScroll(options: CheckScrollOptions) {\n        if (this._isWait) {\n            return false;\n        }\n        const {\n            prevScrollPos = this._prevScrollPos,\n            direction,\n            throttleTime = 0,\n            inputEvent,\n            isDrag,\n        } = options;\n        const nextScrollPos = this._getScrollPosition(direction || [0, 0], options);\n        const offsetX = nextScrollPos[0] - prevScrollPos[0];\n        const offsetY = nextScrollPos[1] - prevScrollPos[1];\n\n        const nextDirection = direction || [\n            offsetX ? Math.abs(offsetX) / offsetX : 0,\n            offsetY ? Math.abs(offsetY) / offsetY : 0,\n        ];\n        this._prevScrollPos = nextScrollPos;\n        this._lock = false;\n\n        if (!offsetX && !offsetY) {\n            return false;\n        }\n        /**\n         * @event DragScroll#move\n         */\n        this.emit(\"move\", {\n            offsetX: nextDirection[0] ? offsetX : 0,\n            offsetY: nextDirection[1] ? offsetY : 0,\n            inputEvent,\n        });\n\n        if (throttleTime && isDrag) {\n            clearTimeout(this._timer);\n            this._timer = window.setTimeout(() => {\n                this._continueDrag(options);\n            }, throttleTime);\n        }\n        return true;\n    }\n    /**\n     *\n     */\n    public dragEnd() {\n        this._flag = false;\n        this._lock = false;\n        clearTimeout(this._timer);\n        this._unregisterScrollEvent();\n    }\n    private _getScrollPosition(direction: number[], options: DragScrollOptions) {\n        const {\n            container,\n            getScrollPosition = getDefaultScrollPosition,\n        } = options;\n        return getScrollPosition({ container: getContainerElement(container), direction });\n    }\n    private _continueDrag(options: CheckScrollOptions) {\n        const {\n            container,\n            direction,\n            throttleTime,\n            useScroll,\n            isDrag,\n            inputEvent,\n        } = options;\n\n        if (!this._flag || (isDrag && this._isWait)) {\n            return;\n        }\n        const nowTime = now();\n        const distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);\n\n        if (distTime > 0) {\n            clearTimeout(this._timer);\n            this._timer = window.setTimeout(() => {\n                this._continueDrag(options);\n            }, distTime);\n\n            return false;\n        }\n        this._prevTime = nowTime;\n        const prevScrollPos = this._getScrollPosition(direction, options);\n\n        this._prevScrollPos = prevScrollPos;\n\n        if (isDrag) {\n            this._isWait = true;\n        }\n\n        // unregister native scroll event\n        if (!useScroll) {\n            this._lock = true;\n        }\n        const param = {\n            container: getContainerElement(container),\n            direction,\n            inputEvent,\n        };\n        options.requestScroll?.(param);\n        /**\n         * @event DragScroll#scroll\n         */\n        this.emit(\"scroll\", param);\n\n        this._isWait = false;\n        return useScroll || this.checkScroll({\n            ...options,\n            prevScrollPos,\n            direction,\n            inputEvent,\n        });\n    }\n\n    private _registerScrollEvent(options: DragScrollOptions) {\n        this._unregisterScrollEvent();\n        const checkScrollEvent = options.checkScrollEvent;\n\n        if (!checkScrollEvent) {\n            return;\n        }\n        const callback = checkScrollEvent === true ? checkDefaultScrollEvent : checkScrollEvent;\n        const container = getContainerElement(options.container);\n\n        if (checkScrollEvent === true && (container === document.body || container === document.documentElement)) {\n            this._unregister = checkDefaultScrollEvent(window, this._onScroll);\n        } else {\n            this._unregister = callback(container, this._onScroll);\n        }\n    }\n    private _unregisterScrollEvent() {\n        this._unregister?.();\n        this._unregister = null;\n    }\n\n    private _onScroll = () => {\n        const options = this._currentOptions;\n        if (this._lock || !options) {\n            return;\n        }\n\n        this.emit(\"scrollDrag\", {\n            next: (inputEvent: any) => {\n                this.checkScroll({\n                    container: options.container,\n                    inputEvent,\n                });\n            },\n        });\n    };\n}\n\nexport default DragScroll;\n", "import { names } from \"keycode\";\n\nconst codeData = {\n    \"+\": \"plus\",\n    \"left command\": \"meta\",\n    \"right command\": \"meta\",\n};\nconst keysSort = {\n    shift: 1,\n    ctrl: 2,\n    alt: 3,\n    meta: 4,\n};\n\n/**\n * @memberof KeyController\n */\nexport function getKey(keyCode: number, keyName?: string): string {\n    let key = (names[keyCode] || keyName || \"\").toLowerCase();\n\n    for (const name in codeData) {\n        key = key.replace(name, codeData[name]);\n    }\n    return key.replace(/\\s/g, \"\");\n}\n\n/**\n * @memberof KeyController\n */\nexport function getCombi(e: KeyboardEvent, key: string = getKey(e.keyCode, e.key)): string[] {\n    const keys = getModifierCombi(e);\n    keys.indexOf(key) === -1 && keys.push(key);\n\n    return keys.filter(Boolean);\n}\n\n/**\n * @memberof KeyController\n */\nexport function getModifierCombi(e: KeyboardEvent): string[] {\n    const keys = [e.shiftKey && \"shift\", e.ctrlKey && \"ctrl\", e.altKey && \"alt\", e.metaKey && \"meta\"];\n\n    return keys.filter(Boolean);\n}\n\n/**\n * @memberof KeyController\n */\nexport function getArrangeCombi(keys: string[]) {\n    const arrangeKeys = keys.slice();\n    arrangeKeys.sort((prev, next) => {\n        const prevScore = keysSort[prev] || 5;\n        const nextScore = keysSort[next] || 5;\n\n        return prevScore - nextScore;\n    });\n\n    return arrangeKeys;\n}\n", "import EventEmitter, { EmitterParam, TargetParam } from \"@scena/event-emitter\";\n\nimport { isString, isArray, addEvent, removeEvent } from \"@daybrush/utils\";\nimport { getArrangeCombi, getKey, getCombi } from \"./utils\";\n\n/**\n * @typedef\n * @memberof KeyController\n */\nexport interface KeyControllerEvent extends EmitterParam {\n    inputEvent: KeyboardEvent;\n    isToggle: boolean;\n    key: string;\n    keyCode: number;\n    ctrlKey: boolean;\n    altKey: boolean;\n    shiftKey: boolean;\n    metaKey: boolean;\n}\n\nexport interface OnKeydown extends KeyControllerEvent {\n\n}\nexport interface OnKeyup extends KeyControllerEvent {\n\n}\nexport interface OnBlur {\n\n}\nexport interface KeyconEvents {\n    keydown: OnKeydown;\n    keyup: OnKeyup;\n    blur: OnBlur;\n}\nexport type KeyControllerEvents = KeyconEvents;\n\nlet globalKeyController!: KeyController;\n\n/**\n */\nclass KeyController extends EventEmitter<KeyconEvents & { [text: string]: any }> {\n    /**\n     */\n    public static get global() {\n        return globalKeyController || (globalKeyController = new KeyController());\n    }\n    public static setGlobal() {\n        return this.global;\n    }\n    /**\n     */\n    public ctrlKey = false;\n    /**\n     */\n    public altKey = false;\n    /**\n     *\n     */\n    public shiftKey = false;\n    /**\n     *\n     */\n    public metaKey = false;\n    /**\n     *\n     */\n    constructor(public container: Window | Document | HTMLElement = window) {\n        super();\n\n        addEvent(container, \"blur\", this.blur);\n        addEvent(container, \"keydown\", this.keydownEvent);\n        addEvent(container, \"keyup\", this.keyupEvent);\n    }\n    public clear = (): this => {\n        this.ctrlKey = false;\n        this.altKey = false;\n        this.shiftKey = false;\n        this.metaKey = false;\n        return this;\n    }\n    /**\n     *\n     */\n    public destroy() {\n        const container = this.container as any;\n\n        this.clear();\n        this.off();\n        removeEvent(container, \"blur\", this.blur);\n        removeEvent(container, \"keydown\", this.keydownEvent);\n        removeEvent(container, \"keyup\", this.keyupEvent);\n    }\n    public keydown(comb: string | string[], callback: (e: KeyControllerEvent) => void): this;\n    public keydown(callback: (e: KeyControllerEvent) => void): this;\n    /**\n     *\n     */\n    public keydown(\n        comb: string | string[] | ((e: KeyControllerEvent) => void),\n        callback?: (e: KeyControllerEvent) => void,\n    ): this {\n        return this.addEvent(\"keydown\", comb, callback);\n    }\n    public offKeydown(comb: string | string[], callback?: (e: KeyControllerEvent) => void): this;\n    public offKeydown(callback: (e: KeyControllerEvent) => void): this;\n    /**\n     *\n     */\n    public offKeydown(\n        comb: string | string[] | ((e: KeyControllerEvent) => void),\n        callback?: (e: KeyControllerEvent) => void,\n    ): this {\n        return this.removeEvent(\"keydown\", comb, callback);\n    }\n    public offKeyup(comb: string | string[], callback?: (e: KeyControllerEvent) => void): this;\n    public offKeyup(callback: (e: KeyControllerEvent) => void): this;\n    /**\n     *\n     */\n    public offKeyup(\n        comb: string | string[] | ((e: KeyControllerEvent) => void),\n        callback?: (e: KeyControllerEvent) => void,\n    ): this {\n        return this.removeEvent(\"keyup\", comb, callback);\n    }\n    public keyup(comb: string | string[], callback: (e: KeyControllerEvent) => void): this;\n    public keyup(callback: (e: KeyControllerEvent) => void): this;\n    /**\n     *\n     */\n    public keyup(\n        comb: string | string[] | ((e: KeyControllerEvent) => void),\n        callback?: (e: KeyControllerEvent) => void,\n    ): this {\n        return this.addEvent(\"keyup\", comb, callback);\n    }\n    private addEvent(\n        type: \"keydown\" | \"keyup\",\n        comb: string | string[] | ((e: KeyControllerEvent) => void),\n        callback?: (e: KeyControllerEvent) => void,\n    ) {\n        if (isArray(comb)) {\n            this.on(`${type}.${getArrangeCombi(comb).join(\".\")}`, callback);\n        } else if (isString(comb)) {\n            this.on(`${type}.${comb}`, callback);\n        } else {\n            this.on(type, comb);\n        }\n        return this;\n    }\n    private removeEvent(\n        type: \"keydown\" | \"keyup\",\n        comb: string | string[] | ((e: KeyControllerEvent) => void) | undefined,\n        callback?: (e: KeyControllerEvent) => void,\n    ) {\n        if (isArray(comb)) {\n            this.off(`${type}.${getArrangeCombi(comb).join(\".\")}`, callback);\n        } else if (isString(comb)) {\n            this.off(`${type}.${comb}`, callback);\n        } else {\n            this.off(type, comb);\n        }\n        return this;\n    }\n    private triggerEvent(type: \"keydown\" | \"keyup\", e: KeyboardEvent) {\n        this.ctrlKey = e.ctrlKey;\n        this.shiftKey = e.shiftKey;\n        this.altKey = e.altKey;\n        this.metaKey = e.metaKey;\n\n        const key = getKey(e.keyCode, e.key);\n        const isToggle = key === \"ctrl\"\n            || key === \"shift\"\n            || key === \"meta\"\n            || key === \"alt\";\n        const param: TargetParam<KeyControllerEvent> = {\n            key,\n            isToggle,\n            inputEvent: e,\n            keyCode: e.keyCode,\n            ctrlKey: e.ctrlKey,\n            altKey: e.altKey,\n            shiftKey: e.shiftKey,\n            metaKey: e.metaKey,\n        };\n        this.trigger(type, param);\n        this.trigger(`${type}.${key}`, param);\n\n        const combi = getCombi(e, key);\n\n        combi.length > 1 && this.trigger(`${type}.${combi.join(\".\")}`, param);\n    }\n    private keydownEvent = (e: KeyboardEvent) => {\n        this.triggerEvent(\"keydown\", e);\n    }\n    private keyupEvent = (e: KeyboardEvent) => {\n        this.triggerEvent(\"keyup\", e);\n    }\n    private blur = () => {\n        this.clear();\n        this.trigger(\"blur\");\n    }\n}\n\nexport default KeyController;\n", "import { ReactiveAdapter, reactive, Ref, observe, ReactiveObject, Observer } from \"@cfcs/core\";\nimport KeyController, { KeyControllerEvents, KeyControllerEvent } from \"./KeyController\";\n\nexport interface ReactiveKeyControllerData {\n    ref?: Ref<HTMLElement | null | undefined>;\n    checker?: (e: KeyControllerEvent) => boolean;\n    keys: string | string[];\n}\n\nexport type ReactiveKeyController = ReactiveObject<{\n    inst: KeyController;\n    keys: string | string[];\n    isKeydown: Observer<boolean>;\n    destroy(): void;\n}>;\n\nlet instanceMap!: Map<HTMLElement | Window | Document, {\n    inst: KeyController;\n    count: number;\n}>;\n\nexport const REACTIVE: ReactiveAdapter<\n    ReactiveKeyController,\n    { isKeydown: boolean },\n    never,\n    ReactiveKeyControllerData,\n    KeyControllerEvents\n> = {\n    events: [\"keydown\", \"keyup\", \"blur\"],\n    state: { isKeydown: false },\n    mounted(data) {\n        if (!instanceMap) {\n            instanceMap = new Map();\n        }\n        const element = data.ref?.current ?? window;\n\n        let info = instanceMap.get(element);\n\n        if (!info) {\n            info = {\n                inst: new KeyController(element),\n                count: 0,\n            };\n\n            instanceMap.set(element, info);\n        }\n        ++info.count;\n\n        const keycon = info.inst;\n        const keys = data.keys;\n        const isKeydown = observe(false);\n        const checker = data.checker;\n\n        keycon.keydown(keys, (e: KeyControllerEvent) => {\n            if (!checker || checker(e)) {\n                isKeydown.current = true;\n            }\n        });\n        keycon.keyup(keys, () => {\n            isKeydown.current = false;\n        });\n        keycon.on(\"blur\", () => {\n            isKeydown.current = false;\n        });\n\n        return reactive({\n            inst: keycon,\n            keys,\n            destroy: () => keycon.destroy(),\n            isKeydown,\n        });\n    },\n    destroy({ inst }) {\n        const element = inst.container;\n        const info = instanceMap.get(element);\n\n        --info.count;\n        if (!info.count) {\n            inst.destroy();\n            instanceMap.delete(element);\n        }\n    },\n    on(inst, name, callback) {\n        const keycon = inst.inst;\n\n        if (name === \"keydown\") {\n            keycon.keydown(inst.keys, callback as any);\n        } else if (name === \"keyup\") {\n            keycon.keyup(inst.keys, callback as any);\n        } else {\n            keycon.on(name, callback as any);\n        }\n    },\n    off(inst, name, callback) {\n        const keycon = inst.inst;\n\n        if (name === \"keydown\") {\n            keycon.offKeydown(inst.keys, callback as any);\n        } else if (name === \"keyup\") {\n            keycon.offKeyup(inst.keys, callback as any);\n        } else {\n            keycon.off(name, callback as any);\n        }\n    },\n}\n", "import { throttle, TINY_NUM } from \"@daybrush/utils\";\n\nexport function tinyThrottle(num: number) {\n    return throttle(num, TINY_NUM);\n}\n\nexport function isSameConstants(\n    linearConstants1: number[],\n    linearConstants2: number[],\n) {\n    return linearConstants1.every((v, i) => tinyThrottle(v - linearConstants2[i]) === 0);\n}\n\nexport function isSamePoint(\n    point1: number[],\n    point2: number[],\n) {\n    return !tinyThrottle(point1[0] - point2[0]) && !tinyThrottle(point1[1] - point2[1]);\n}\n\nexport function flat<Type extends any>(arr: Type[][]): Type[] {\n    return arr.reduce<Type[]>((prev, current) => {\n        prev.push(...current);\n        return prev;\n    }, []);\n}\n", "import { sum, findIndex, getShapeDirection, getDist, throttle, TINY_NUM, find } from \"@daybrush/utils\";\nimport { OverlapPointInfo, PointInfo, Rect } from \"./types\";\nimport { flat, isSameConstants, isSamePoint, tinyThrottle } from \"./utils\";\n\n/**\n * @namespace OverlapArea\n */\n\n/**\n * Gets the size of a shape (polygon) made of points.\n * @memberof OverlapArea\n */\nexport function getAreaSize(points: number[][]): number {\n    if (points.length < 3) {\n        return 0;\n    }\n    return Math.abs(sum(points.map((point, i) => {\n        const nextPoint = points[i + 1] || points[0];\n\n        return point[0] * nextPoint[1] - nextPoint[0] * point[1];\n    }))) / 2;\n}\n\n\n/**\n * Get points that fit the rect,\n * @memberof OverlapArea\n */\nexport function fitPoints(points: number[][], rect: Rect): number[][] {\n    const { width, height, left, top } = rect;\n    const { minX, minY, maxX, maxY } = getMinMaxs(points);\n    const ratioX = width / (maxX - minX);\n    const ratioY = height / (maxY - minY);\n\n    return points.map(point => {\n        return [\n            left + (point[0] - minX) * ratioX,\n            top + (point[1] - minY) * ratioY,\n        ];\n    });\n}\n/**\n * Get the minimum and maximum points of the points.\n * @memberof OverlapArea\n */\nexport function getMinMaxs(points: number[][]): { minX: number, minY: number, maxX: number, maxY: number } {\n    const xs = points.map(point => point[0]);\n    const ys = points.map(point => point[1]);\n\n    return {\n        minX: Math.min(...xs),\n        minY: Math.min(...ys),\n        maxX: Math.max(...xs),\n        maxY: Math.max(...ys),\n    };\n}\n/**\n * Whether the point is in shape\n * @param - point pos\n * @param - shape points\n * @param - whether to check except line\n * @memberof OverlapArea\n */\nexport function isInside(pos: number[], points: number[][], excludeLine?: boolean): boolean {\n    const [x, y] = pos;\n    const {\n        minX,\n        maxX,\n    } = getMinMaxs(points);\n\n    const xLine = [[minX, y], [maxX, y]];\n    const xLinearConstants = getLinearConstants(xLine[0], xLine[1]);\n    const lines = convertLines(points);\n\n    interface IntersectionPosInfo {\n        pos: number[];\n        line: number[][];\n        type: \"intersection\" | \"point\" | \"line\";\n    }\n    const intersectionPosInfos: IntersectionPosInfo[] = [];\n\n    lines.forEach(line => {\n        const linearConstants = getLinearConstants(line[0], line[1]);\n        const standardPoint = line[0];\n\n        if (isSameConstants(xLinearConstants, linearConstants)) {\n            intersectionPosInfos.push({\n                pos: pos,\n                line,\n                type: \"line\",\n            });\n        } else {\n            const xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);\n\n            xPoints.forEach(point => {\n                if (line.some(linePoint => isSamePoint(linePoint, point))) {\n                    intersectionPosInfos.push({\n                        pos: point,\n                        line,\n                        type: \"point\",\n                    });\n                } else if (tinyThrottle(standardPoint[1] - y) !== 0) {\n                    intersectionPosInfos.push({\n                        pos: point,\n                        line,\n                        type: \"intersection\",\n                    });\n                }\n            })\n        }\n    });\n\n    if (!excludeLine) {\n        // on line\n        if (find(intersectionPosInfos, p => p[0] === x)) {\n            return true;\n        }\n    }\n    let intersectionCount = 0;\n    const xMap = {};\n\n    intersectionPosInfos.forEach(({ pos, type, line }) => {\n        if (pos[0] > x) {\n            return;\n        }\n        if (type === \"intersection\") {\n            ++intersectionCount;\n        } else if (type === \"line\") {\n            return;\n        } else if (type === \"point\") {\n            const point = find(line, linePoint => linePoint[1] !== y);\n            const prevValue = xMap[pos[0]];\n            const nextValue = point[1] > y ? 1 : -1;\n\n            if (!prevValue) {\n                xMap[pos[0]] = nextValue;\n            } else if (prevValue !== nextValue) {\n                ++intersectionCount;\n            }\n        }\n    });\n    return intersectionCount % 2 === 1;\n}\n/**\n * Get distance from point to constants. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\nexport function getDistanceFromPointToConstants(\n    [a, b, c]: [number, number, number],\n    pos: number[],\n) {\n    return (a * pos[0] + b * pos[1] + c) / (a * a + b * b);\n}\n\n/**\n * Get the coefficient of the linear function. [a, b, c] (ax + by + c = 0)\n * @return [a, b, c]\n * @memberof OverlapArea\n */\nexport function getLinearConstants(point1: number[], point2: number[]): [number, number, number] {\n    const [x1, y1] = point1;\n    const [x2, y2] = point2;\n    // ax + by + c = 0\n    // [a, b, c]\n    let dx = x2 - x1;\n    let dy = y2 - y1;\n\n    if (Math.abs(dx) < TINY_NUM) {\n        dx = 0;\n    }\n    if (Math.abs(dy) < TINY_NUM) {\n        dy = 0;\n    }\n\n    // b > 0\n    // ax + by + c = 0\n    let a = 0;\n    let b = 0;\n    let c = 0;\n    if (!dx) {\n        if (dy) {\n            // -x + 1 = 0\n            a = -1;\n            c = x1;\n        }\n    } else if (!dy) {\n        // y - 1 = 0\n        b = 1;\n        c = -y1;\n    } else {\n        // y = -a(x - x1) + y1\n        // ax + y + a * x1 - y1 = 0\n        a = -dy / dx;\n        b = 1;\n        c = -a * x1 - y1;\n    }\n\n    return [a, b, c] as [number, number, number];\n}\n/**\n * Get intersection points with linear functions.\n * @memberof OverlapArea\n */\nexport function getIntersectionPointsByConstants(\n    linearConstants1: number[],\n    linearConstants2: number[],\n): number[][] {\n    const [a1, b1, c1] = linearConstants1;\n    const [a2, b2, c2] = linearConstants2;\n\n    const isZeroA = a1 === 0 && a2 === 0;\n    const isZeroB = b1 === 0 && b2 === 0;\n    let results: number[][] = [];\n\n    if (isZeroA && isZeroB) {\n        return [];\n    } else if (isZeroA) {\n        // b1 * y + c1 = 0\n        // b2 * y + c2 = 0\n        const y1 = -c1 / b1;\n        const y2 = -c2 / b2;\n\n        if (y1 !== y2) {\n            return [];\n        } else {\n            return [\n                [-Infinity, y1],\n                [Infinity, y1],\n            ];\n        }\n    } else if (isZeroB) {\n        // a1 * x + c1 = 0\n        // a2 * x + c2 = 0\n        const x1 = -c1 / a1;\n        const x2 = -c2 / a2;\n\n        if (x1 !== x2) {\n            return [];\n        } else {\n            return [\n                [x1, -Infinity],\n                [x1, Infinity],\n            ];\n        }\n    } else if (a1 === 0) {\n        // b1 * y + c1 = 0\n        // y = - c1 / b1;\n        // a2 * x + b2 * y + c2 = 0\n        const y = -c1 / b1;\n        const x = -(b2 * y + c2) / a2;\n\n        results = [[x, y]];\n    } else if (a2 === 0) {\n        // b2 * y + c2 = 0\n        // y = - c2 / b2;\n        // a1 * x + b1 * y + c1 = 0\n        const y = -c2 / b2;\n        const x = -(b1 * y + c1) / a1;\n\n        results = [[x, y]];\n    } else if (b1 === 0) {\n        // a1 * x + c1 = 0\n        // x = - c1 / a1;\n        // a2 * x + b2 * y + c2 = 0\n        const x = - c1 / a1;\n        const y = -(a2 * x + c2) / b2;\n\n        results = [[x, y]];\n    } else if (b2 === 0) {\n        // a2 * x + c2 = 0\n        // x = - c2 / a2;\n        // a1 * x + b1 * y + c1 = 0\n        const x = - c2 / a2;\n        const y = -(a1 * x + c1) / b1;\n\n        results = [[x, y]];\n    } else {\n        // a1 * x + b1 * y + c1 = 0\n        // a2 * x + b2 * y + c2 = 0\n        // b2 * a1 * x + b2 * b1 * y + b2 * c1 = 0\n        // b1 * a2 * x + b1 * b2 * y + b1 * c2 = 0\n        // (b2 * a1 - b1 * a2)  * x = (b1 * c2 - b2 * c1)\n        const x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);\n        const y = -(a1 * x + c1) / b1;\n\n        results = [[x, y]];\n    }\n\n    return results.map(result => [result[0], result[1]]);\n}\n/**\n * Get intersection points to the two lines.\n * @memberof OverlapArea\n */\nexport function getIntersectionPoints(\n    line1: number[][],\n    line2: number[][],\n    isLimit?: boolean,\n): number[][] {\n    const points = getIntersectionPointsByConstants(\n        getLinearConstants(line1[0], line1[1]),\n        getLinearConstants(line2[0], line2[1]),\n    );\n\n    if (isLimit) {\n        return getPointsOnLines(points, [line1, line2]);\n    }\n    return points;\n}\n\nexport function isPointOnLine(\n    pos: number[],\n    line: number[][],\n) {\n    const linearConstants = getLinearConstants(line[0], line[1]);\n\n    return tinyThrottle(getDistanceFromPointToConstants(linearConstants, pos)) === 0;\n}\n\n/**\n * Get the points on the lines (between two points).\n * @memberof OverlapArea\n */\nexport function getPointsOnLines(\n    points: number[][],\n    lines: number[][][],\n): number[][] {\n    const minMaxs = lines.map(line => [0, 1].map(order => [\n        Math.min(line[0][order], line[1][order]),\n        Math.max(line[0][order], line[1][order]),\n    ]));\n    let results: number[][] = [];\n\n    if (points.length === 2) {\n        const [x, y] = points[0];\n        if (!tinyThrottle(x - points[1][0])) {\n            /// Math.max(minY1, minY2)\n            const top = Math.max(...minMaxs.map(minMax => minMax[1][0]));\n            /// Math.min(maxY1, miax2)\n            const bottom = Math.min(...minMaxs.map(minMax => minMax[1][1]));\n\n            if (tinyThrottle(top - bottom) > 0) {\n                return [];\n            }\n            results = [\n                [x, top],\n                [x, bottom],\n            ];\n        } else if (!tinyThrottle(y - points[1][1])) {\n            /// Math.max(minY1, minY2)\n            const left = Math.max(...minMaxs.map(minMax => minMax[0][0]));\n            /// Math.min(maxY1, miax2)\n            const right = Math.min(...minMaxs.map(minMax => minMax[0][1]));\n\n            if (tinyThrottle(left - right) > 0) {\n                return [];\n            }\n            results = [\n                [left, y],\n                [right, y],\n            ];\n        }\n    }\n\n    if (!results.length) {\n        results = points.filter(point => {\n            const [pointX, pointY] = point;\n\n            return minMaxs.every(minMax => {\n                return (0 <= tinyThrottle(pointX - minMax[0][0]) && 0 <= tinyThrottle(minMax[0][1] - pointX))\n                && (0 <= tinyThrottle(pointY - minMax[1][0]) && 0 <= tinyThrottle(minMax[1][1] - pointY));\n            });\n        });\n    }\n\n    return results.map(result => [tinyThrottle(result[0]), tinyThrottle(result[1])]);\n\n}\n/**\n* Convert two points into lines.\n* @function\n* @memberof OverlapArea\n*/\nexport function convertLines(points: number[][]): number[][][] {\n    return [...points.slice(1), points[0]].map((point, i) => [points[i], point]);\n}\n\nfunction getOverlapPointInfos(points1: number[][], points2: number[][]): OverlapPointInfo[] {\n    const targetPoints1 = points1.slice();\n    const targetPoints2 = points2.slice();\n\n    if (getShapeDirection(targetPoints1) === -1) {\n        targetPoints1.reverse();\n    }\n    if (getShapeDirection(targetPoints2) === -1) {\n        targetPoints2.reverse();\n    }\n    const lines1 = convertLines(targetPoints1);\n    const lines2 = convertLines(targetPoints2);\n    const linearConstantsList1 = lines1.map(line1 => getLinearConstants(line1[0], line1[1]));\n    const linearConstantsList2 = lines2.map(line2 => getLinearConstants(line2[0], line2[1]));\n\n    const overlapInfos: OverlapPointInfo[] = [];\n\n    linearConstantsList1.forEach((linearConstants1, i) => {\n        const line1 = lines1[i];\n        const linePointInfos: OverlapPointInfo[] = [];\n        linearConstantsList2.forEach((linearConstants2, j) => {\n            const intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);\n            const points = getPointsOnLines(intersectionPoints, [line1, lines2[j]]);\n\n            linePointInfos.push(...points.map(pos => ({\n                index1: i,\n                index2: j,\n                pos,\n                type: \"intersection\" as const,\n            })));\n        });\n        linePointInfos.sort((a, b) => {\n            return getDist(line1[0], a.pos) - getDist(line1[0], b.pos);\n        });\n\n        overlapInfos.push(...linePointInfos);\n\n        if (isInside(line1[1], targetPoints2)) {\n            overlapInfos.push({\n                index1: i,\n                index2: -1,\n                pos: line1[1],\n                type: \"inside\" as const,\n            });\n        }\n    });\n\n    lines2.forEach((line2, i) => {\n        if (!isInside(line2[1], targetPoints1)) {\n            return;\n        }\n        let isNext = false;\n        let index = findIndex(overlapInfos, ({ index2 }) => {\n            if (index2 === i) {\n                isNext = true;\n                return false;\n            }\n\n            if (isNext) {\n                return true;\n            }\n            return false;\n        });\n        if (index === -1) {\n            isNext = false;\n            index = findIndex(overlapInfos, ({ index1, index2 }) => {\n                if (index1 === -1 && index2 + 1 === i) {\n                    isNext = true;\n                    return false;\n                }\n\n                if (isNext) {\n                    return true;\n                }\n                return false;\n            });\n        }\n        if (index === -1) {\n            overlapInfos.push({\n                index1: -1,\n                index2: i,\n                pos: line2[1],\n                type: \"inside\" as const,\n            });\n        } else {\n            overlapInfos.splice(index, 0, {\n                index1: -1,\n                index2: i,\n                pos: line2[1],\n                type: \"inside\" as const,\n            });\n\n        }\n    });\n    const pointMap: Record<string, boolean> = {};\n\n    return overlapInfos.filter(({ pos }) => {\n        const key = `${pos[0]}x${pos[1]}`;\n\n        if (pointMap[key]) {\n            return false;\n        }\n        pointMap[key] = true;\n        return true;\n    });\n}\n\n/**\n* Get the points of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapPoints(points1: number[][], points2: number[][]): number[][] {\n    const infos = getOverlapPointInfos(points1, points2);\n\n    return infos.map(({ pos }) => pos);\n}\n\nfunction isConnectedLine(line: OverlapPointInfo[]) {\n    const {\n        0: {\n            index1: prevIndex1,\n            index2: prevIndex2,\n        },\n        1: {\n            index1: nextIndex1,\n            index2: nextIndex2,\n        }\n    } = line;\n\n    if (prevIndex1 !== -1) {\n        // same line\n        if (prevIndex1 === nextIndex1) {\n            return true;\n        }\n        if (prevIndex1 + 1 === nextIndex1) {\n            return true;\n        }\n    }\n    if (prevIndex2 !== -1) {\n        // same line\n        if (prevIndex2 === nextIndex2) {\n            return true;\n        }\n        if (prevIndex2 + 1 === nextIndex2) {\n            return true;\n        }\n    }\n\n    return false;\n\n}\n/**\n* Get the areas of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapAreas(points1: number[][], points2: number[][]): number[][][] {\n    const infos = getOverlapPointInfos(points1, points2);\n    const areas: OverlapPointInfo[][] = [];\n    let area: OverlapPointInfo[];\n\n    getOverlapPointInfos(points1, points2).forEach((info, i, arr) => {\n        if (i === 0 || !isConnectedLine([arr[i - 1], info])) {\n            area = [info];\n            areas.push(area);\n        } else {\n            area.push(info);\n        }\n    });\n\n    return areas.map(area => area.map(({ pos }) => pos));\n}\nfunction findReversedAreas(points1: number[][], points2: number[][], index: number = 0, areas: number[][][] = []): number[][][] {\n    const isFirst = areas.length === 0;\n    const length = points1.length;\n    const nextIndex = points1[index] ? index : 0;\n    const nextPoints1 = [...points1.slice(nextIndex), ...points1.slice(0, nextIndex)];\n\n    for (let i = 0; i < length; ++i) {\n        const point1 = nextPoints1[i];\n\n        if (find(points2, point2 => point2[0] === point1[0] && point2[1] === point1[1])) {\n            continue;\n        }\n        if (areas.some(nextArea => find(nextArea, areaPoint => areaPoint[0] === point1[0] && areaPoint[1] === point1[1]))) {\n            if (isFirst) {\n                continue;\n            } else {\n                break;\n            }\n        }\n        let nextArea: number[][];\n\n        if (isFirst) {\n            nextArea = [];\n            areas.push(nextArea);\n        } else {\n            nextArea = areas[areas.length - 1];\n        }\n        nextArea.push(point1);\n\n\n        const line = [point1, points1[index + 1] || points1[0]];\n        const nextPoint2 = points2.filter(point2 => {\n            return isPointOnLine(point2, line);\n        }).sort((a, b) => {\n            return getDist(point1, a) - getDist(point1, b);\n        })[0];\n\n        if (!nextPoint2) {\n            findReversedAreas(nextPoints1, points2, i + 1, areas);\n            break;\n        } else {\n            const point2Index = points2.indexOf(nextPoint2);\n\n            findReversedAreas(points2, points1, point2Index, areas);\n            if (!isFirst) {\n                break;\n            }\n        }\n    }\n    return areas;\n}\nexport function findConnectedAreas(points1: number[][], points2: number[][]) {\n    return findReversedAreas(points1, [...points2].reverse());\n}\n/**\n* Get non-overlapping areas of two shapes based on points1.\n* @memberof OverlapArea\n*/\nexport function getUnoverlapAreas(points1: number[][], points2: number[][]): number[][][] {\n    if (!points2.length) {\n        return [[...points1]];\n    }\n    const overlapAreas = getOverlapAreas(points1, points2);\n     let unoverlapAreas = [points1];\n\n    overlapAreas.forEach(overlapArea => {\n        const nextOverlapArea = [...overlapArea].reverse();\n\n        unoverlapAreas = flat(unoverlapAreas.map(area => {\n            const connectedAreas = findReversedAreas(area, nextOverlapArea);\n            const firstConnectedArea = connectedAreas[0];\n\n            if (connectedAreas.length === 1 && nextOverlapArea.every(point => firstConnectedArea.indexOf(point) === -1)) {\n                const lastPoint = firstConnectedArea[firstConnectedArea.length - 1];\n                const firstPoint = [...nextOverlapArea].sort((a, b) => {\n                    return getDist(lastPoint, a) - getDist(lastPoint, b);\n                })[0];\n                const firstIndex = nextOverlapArea.indexOf(firstPoint);\n\n                firstConnectedArea.push(\n                    ...nextOverlapArea.slice(firstIndex),\n                    ...nextOverlapArea.slice(0, firstIndex),\n                    nextOverlapArea[firstIndex],\n                    lastPoint,\n                );\n            }\n            return connectedAreas;\n        }));\n    });\n\n    return unoverlapAreas;\n}\n/**\n* Gets the size of the overlapped part of two shapes.\n* @function\n* @memberof OverlapArea\n*/\nexport function getOverlapSize(points1: number[][], points2: number[][]): number {\n    const points = getOverlapPoints(points1, points2);\n\n    return getAreaSize(points);\n}\n", "import { average, throttle, TINY_NUM } from \"@daybrush/utils\";\n\nfunction add(\n    matrix: number[],\n    inverseMatrix: number[],\n    startIndex: number,\n    fromIndex: number,\n    n: number,\n    k: number,\n) {\n    for (let i = 0; i < n; ++i) {\n        const x = startIndex + i * n;\n        const fromX = fromIndex + i * n;\n        matrix[x] += matrix[fromX] * k;\n        inverseMatrix[x] += inverseMatrix[fromX] * k;\n    }\n}\n\nfunction swap(\n    matrix: number[],\n    inverseMatrix: number[],\n    startIndex: number,\n    fromIndex: number,\n    n: number,\n) {\n    for (let i = 0; i < n; ++i) {\n        const x = startIndex + i * n;\n        const fromX = fromIndex + i * n;\n        const v = matrix[x];\n        const iv = inverseMatrix[x];\n\n        matrix[x] = matrix[fromX];\n        matrix[fromX] = v;\n\n        inverseMatrix[x] = inverseMatrix[fromX];\n        inverseMatrix[fromX] = iv;\n    }\n}\n\nfunction divide(\n    matrix: number[],\n    inverseMatrix: number[],\n    startIndex: number,\n    n: number,\n    k: number,\n) {\n    for (let i = 0; i < n; ++i) {\n        const x = startIndex + i * n;\n\n        matrix[x] /= k;\n        inverseMatrix[x] /= k;\n    }\n}\n\n/**\n *\n * @namespace Matrix\n */\n/**\n * @memberof Matrix\n */\nexport function ignoreDimension(\n    matrix: number[],\n    m: number,\n    n: number = Math.sqrt(matrix.length),\n) {\n    const newMatrix = matrix.slice();\n\n    for (let i = 0; i < n; ++i) {\n        newMatrix[i * n + m - 1] = 0;\n        newMatrix[(m - 1) * n + i] = 0;\n    }\n    newMatrix[(m - 1) * (n + 1)] = 1;\n\n    return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function invert(\n    matrix: number[],\n    n: number = Math.sqrt(matrix.length),\n) {\n    const newMatrix = matrix.slice();\n    const inverseMatrix = createIdentityMatrix(n);\n\n    for (let i = 0; i < n; ++i) {\n        // diagonal\n        const identityIndex = n * i + i;\n\n        if (!throttle(newMatrix[identityIndex], TINY_NUM)) {\n            // newMatrix[identityIndex] = 0;\n            for (let j = i + 1; j < n; ++j) {\n                if (newMatrix[n * i + j]) {\n                    swap(newMatrix, inverseMatrix, i, j, n);\n                    break;\n                }\n            }\n        }\n        if (!throttle(newMatrix[identityIndex], TINY_NUM)) {\n            // no inverse matrix\n            return [];\n        }\n        divide(newMatrix, inverseMatrix, i, n, newMatrix[identityIndex]);\n        for (let j = 0; j < n; ++j) {\n            const targetStartIndex = j;\n            const targetIndex = j + i * n;\n            const target = newMatrix[targetIndex];\n\n            if (!throttle(target, TINY_NUM) || i === j) {\n                continue;\n            }\n            add(newMatrix, inverseMatrix, targetStartIndex, i, n, -target);\n        }\n    }\n\n    return inverseMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function transpose(matrix: number[], n: number = Math.sqrt(matrix.length)) {\n    const newMatrix: number[] = [];\n\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < n; ++j) {\n            newMatrix[j * n + i] = matrix[n * i + j];\n        }\n    }\n    return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function getOrigin(matrix: number[], n: number = Math.sqrt(matrix.length)) {\n    const originMatrix: number[] = [];\n    const w = matrix[n * n - 1];\n    for (let i = 0; i < n - 1; ++i) {\n        originMatrix[i] = matrix[n * (n - 1) + i] / w;\n    }\n    originMatrix[n - 1] = 0;\n    return originMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function fromTranslation(pos: number[], n: number) {\n    const newMatrix = createIdentityMatrix(n);\n\n    for (let i = 0; i < n - 1; ++i) {\n        newMatrix[n * (n - 1) + i] = pos[i] || 0;\n    }\n    return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function convertPositionMatrix(matrix: number[], n: number) {\n    const newMatrix = matrix.slice();\n\n    for (let i = matrix.length; i < n - 1; ++i) {\n        newMatrix[i] = 0;\n    }\n    newMatrix[n - 1] = 1;\n    return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function convertDimension(matrix: number[], n: number = Math.sqrt(matrix.length), m: number) {\n    // n < m\n    if (n === m) {\n        return matrix;\n    }\n    const newMatrix = createIdentityMatrix(m);\n\n    const length = Math.min(n, m);\n    for (let i = 0; i < length - 1; ++i) {\n        for (let j = 0; j < length - 1; ++j) {\n            newMatrix[i * m + j] = matrix[i * n + j];\n        }\n\n        newMatrix[(i + 1) * m - 1] = matrix[(i + 1) * n - 1];\n        newMatrix[(m - 1) * m + i] = matrix[(n - 1) * n + i];\n    }\n    newMatrix[m * m - 1] = matrix[n * n - 1];\n\n    return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function multiplies(n: number, ...matrixes: number[][]) {\n    let m: number[] = createIdentityMatrix(n);\n\n    matrixes.forEach(matrix => {\n        m = multiply(m, matrix, n);\n    });\n    return m;\n}\n\n/**\n * @memberof Matrix\n */\nexport function multiply(matrix: number[], matrix2: number[], n: number = Math.sqrt(matrix.length)) {\n    const newMatrix: number[] = [];\n    // 1 y: n\n    // 1 x: m\n    // 2 x: m\n    // 2 y: k\n    // n * m X m * k\n    const m = matrix.length / n;\n    const k = matrix2.length / m;\n\n    if (!m) {\n        return matrix2;\n    } else if (!k) {\n        return matrix;\n    }\n    for (let i = 0; i < n; ++i) {\n        for (let j = 0; j < k; ++j) {\n            newMatrix[j * n + i] = 0;\n            for (let l = 0; l < m; ++l) {\n                // m1 x: m(l), y: n(i)\n                // m2 x: k(j):  y: m(l)\n                // nw x: n(i), y: k(j)\n                newMatrix[j * n + i] += matrix[l * n + i] * matrix2[j * m + l];\n            }\n        }\n    }\n    // n * k\n    return newMatrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function plus(pos1: number[], pos2: number[]) {\n    const length = Math.min(pos1.length, pos2.length);\n    const nextPos = pos1.slice();\n\n    for (let i = 0; i < length; ++i) {\n        nextPos[i] = nextPos[i] + pos2[i];\n    }\n    return nextPos;\n}\n\n/**\n * @memberof Matrix\n */\nexport function minus(pos1: number[], pos2: number[]) {\n    const length = Math.min(pos1.length, pos2.length);\n    const nextPos = pos1.slice();\n\n    for (let i = 0; i < length; ++i) {\n        nextPos[i] = nextPos[i] - pos2[i];\n    }\n    return nextPos;\n}\n\n/**\n * @memberof Matrix\n */\nexport function convertCSStoMatrix(a: number[], is2d: boolean = a.length === 6) {\n    if (is2d) {\n        return [\n            a[0], a[1], 0,\n            a[2], a[3], 0,\n            a[4], a[5], 1,\n        ];\n    }\n    return a;\n}\n\n/**\n * @memberof Matrix\n */\nexport function convertMatrixtoCSS(a: number[], is2d: boolean = a.length === 9) {\n    if (is2d) {\n        return [\n            a[0], a[1],\n            a[3], a[4],\n            a[6], a[7],\n        ];\n    }\n    return a;\n}\n\n/**\n * @memberof Matrix\n */\nexport function calculate(matrix: number[], matrix2: number[], n: number = matrix2.length) {\n    const result = multiply(matrix, matrix2, n);\n    const k = result[n - 1];\n    return result.map(v => v / k);\n}\n\n/**\n * @memberof Matrix\n */\nexport function rotateX3d(matrix: number[], rad: number) {\n    return multiply(\n        matrix,\n        [\n            1, 0, 0, 0,\n            0, Math.cos(rad), Math.sin(rad), 0,\n            0, -Math.sin(rad), Math.cos(rad), 0,\n            0, 0, 0, 1,\n        ],\n        4,\n    );\n}\n\n/**\n * @memberof Matrix\n */\nexport function rotateY3d(matrix: number[], rad: number) {\n    return multiply(\n        matrix,\n        [\n            Math.cos(rad), 0, -Math.sin(rad), 0,\n            0, 1, 0, 0,\n            Math.sin(rad), 0, Math.cos(rad), 0,\n            0, 0, 0, 1,\n        ],\n        4,\n    );\n}\n\n/**\n * @memberof Matrix\n */\nexport function rotateZ3d(matrix: number[], rad: number) {\n    return multiply(\n        matrix,\n        createRotateMatrix(rad, 4),\n    );\n}\n\n/**\n * @memberof Matrix\n */\nexport function scale3d(matrix: number[], [\n    sx = 1,\n    sy = 1,\n    sz = 1,\n]: number[]) {\n    return multiply(\n        matrix,\n        [\n            sx, 0, 0, 0,\n            0, sy, 0, 0,\n            0, 0, sz, 0,\n            0, 0, 0, 1,\n        ],\n        4,\n    );\n}\n\n/**\n * @memberof Matrix\n */\nexport function rotate(pos: number[], rad: number) {\n    return calculate(\n        createRotateMatrix(rad, 3),\n        convertPositionMatrix(pos, 3),\n    );\n}\n\n/**\n * @memberof Matrix\n */\nexport function translate3d(matrix, [\n    tx = 0,\n    ty = 0,\n    tz = 0,\n]: number[]) {\n    return multiply(\n        matrix,\n        [\n            1, 0, 0, 0,\n            0, 1, 0, 0,\n            0, 0, 1, 0,\n            tx, ty, tz, 1,\n        ],\n        4,\n    );\n}\n/**\n * @memberof Matrix\n */\nexport function matrix3d(matrix1: number[], matrix2: number[]) {\n    return multiply(matrix1, matrix2, 4);\n}\n\n/**\n * @memberof Matrix\n */\nexport function createRotateMatrix(rad: number, n: number) {\n    const cos = Math.cos(rad);\n    const sin = Math.sin(rad);\n    const m = createIdentityMatrix(n);\n\n    // cos -sin\n    // sin cos\n    m[0] = cos;\n    m[1] = sin;\n    m[n] = -sin;\n    m[n + 1] = cos;\n\n    return m;\n}\n\n/**\n * @memberof Matrix\n */\nexport function createIdentityMatrix(n: number) {\n    const length = n * n;\n    const matrix: number[] = [];\n\n    for (let i = 0; i < length; ++i) {\n        matrix[i] = i % (n + 1) ? 0 : 1;\n    }\n    return matrix;\n}\n\n/**\n * @memberof Matrix\n */\nexport function createScaleMatrix(scale: number[], n: number) {\n    const m = createIdentityMatrix(n);\n    const length = Math.min(scale.length, n - 1);\n\n    for (let i = 0; i < length; ++i) {\n        m[(n + 1) * i] = scale[i];\n    }\n    return m;\n}\n\n/**\n * @memberof Matrix\n */\nexport function createOriginMatrix(origin: number[], n: number) {\n    const m = createIdentityMatrix(n);\n    const length = Math.min(origin.length, n - 1);\n\n    for (let i = 0; i < length; ++i) {\n        m[n * (n - 1) + i] = origin[i];\n    }\n    return m;\n}\n\n/**\n * @memberof Matrix\n */\nexport function createWarpMatrix(\n    pos0: number[],\n    pos1: number[],\n    pos2: number[],\n    pos3: number[],\n    nextPos0: number[],\n    nextPos1: number[],\n    nextPos2: number[],\n    nextPos3: number[],\n) {\n    const [x0, y0] = pos0;\n    const [x1, y1] = pos1;\n    const [x2, y2] = pos2;\n    const [x3, y3] = pos3;\n\n    const [u0, v0] = nextPos0;\n    const [u1, v1] = nextPos1;\n    const [u2, v2] = nextPos2;\n    const [u3, v3] = nextPos3;\n\n    const matrix = [\n        x0, 0, x1, 0, x2, 0, x3, 0,\n        y0, 0, y1, 0, y2, 0, y3, 0,\n        1, 0, 1, 0, 1, 0, 1, 0,\n        0, x0, 0, x1, 0, x2, 0, x3,\n        0, y0, 0, y1, 0, y2, 0, y3,\n        0, 1, 0, 1, 0, 1, 0, 1,\n        -u0 * x0, -v0 * x0, -u1 * x1, -v1 * x1, -u2 * x2, -v2 * x2, -u3 * x3, -v3 * x3,\n        -u0 * y0, -v0 * y0, -u1 * y1, -v1 * y1, -u2 * y2, -v2 * y2, -u3 * y3, -v3 * y3,\n    ];\n    const inverseMatrix = invert(matrix, 8);\n\n    if (!inverseMatrix.length) {\n        return [];\n    }\n    const h = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);\n\n    h[8] = 1;\n    return convertDimension(transpose(h), 3, 4);\n}\n\n/**\n * @memberof Matrix\n */\nexport function getCenter(points: number[][]) {\n    return [0, 1].map(i => average(points.map(pos => pos[i])));\n}\n", "/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\r\n    function accept(f) { if (f !== void 0 && typeof f !== \"function\") throw new TypeError(\"Function expected\"); return f; }\r\n    var kind = contextIn.kind, key = kind === \"getter\" ? \"get\" : kind === \"setter\" ? \"set\" : \"value\";\r\n    var target = !descriptorIn && ctor ? contextIn[\"static\"] ? ctor : ctor.prototype : null;\r\n    var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\r\n    var _, done = false;\r\n    for (var i = decorators.length - 1; i >= 0; i--) {\r\n        var context = {};\r\n        for (var p in contextIn) context[p] = p === \"access\" ? {} : contextIn[p];\r\n        for (var p in contextIn.access) context.access[p] = contextIn.access[p];\r\n        context.addInitializer = function (f) { if (done) throw new TypeError(\"Cannot add initializers after decoration has completed\"); extraInitializers.push(accept(f || null)); };\r\n        var result = (0, decorators[i])(kind === \"accessor\" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\r\n        if (kind === \"accessor\") {\r\n            if (result === void 0) continue;\r\n            if (result === null || typeof result !== \"object\") throw new TypeError(\"Object expected\");\r\n            if (_ = accept(result.get)) descriptor.get = _;\r\n            if (_ = accept(result.set)) descriptor.set = _;\r\n            if (_ = accept(result.init)) initializers.unshift(_);\r\n        }\r\n        else if (_ = accept(result)) {\r\n            if (kind === \"field\") initializers.unshift(_);\r\n            else descriptor[key] = _;\r\n        }\r\n    }\r\n    if (target) Object.defineProperty(target, contextIn.name, descriptor);\r\n    done = true;\r\n};\r\n\r\nexport function __runInitializers(thisArg, initializers, value) {\r\n    var useValue = arguments.length > 2;\r\n    for (var i = 0; i < initializers.length; i++) {\r\n        value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\r\n    }\r\n    return useValue ? value : void 0;\r\n};\r\n\r\nexport function __propKey(x) {\r\n    return typeof x === \"symbol\" ? x : \"\".concat(x);\r\n};\r\n\r\nexport function __setFunctionName(f, name, prefix) {\r\n    if (typeof name === \"symbol\") name = name.description ? \"[\".concat(name.description, \"]\") : \"\";\r\n    return Object.defineProperty(f, \"name\", { configurable: true, value: prefix ? \"\".concat(prefix, \" \", name) : name });\r\n};\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport var __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    var desc = Object.getOwnPropertyDescriptor(m, k);\r\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\r\n        desc = { enumerable: true, get: function() { return m[k]; } };\r\n    }\r\n    Object.defineProperty(o, k2, desc);\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nexport function __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nexport function __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\r\nexport function __classPrivateFieldIn(state, receiver) {\r\n    if (receiver === null || (typeof receiver !== \"object\" && typeof receiver !== \"function\")) throw new TypeError(\"Cannot use 'in' operator on non-object\");\r\n    return typeof state === \"function\" ? receiver === state : state.has(receiver);\r\n}\r\n\r\nexport default {\r\n    __extends,\r\n    __assign,\r\n    __rest,\r\n    __decorate,\r\n    __param,\r\n    __metadata,\r\n    __awaiter,\r\n    __generator,\r\n    __createBinding,\r\n    __exportStar,\r\n    __values,\r\n    __read,\r\n    __spread,\r\n    __spreadArrays,\r\n    __spreadArray,\r\n    __await,\r\n    __asyncGenerator,\r\n    __asyncDelegator,\r\n    __asyncValues,\r\n    __makeTemplateObject,\r\n    __importStar,\r\n    __importDefault,\r\n    __classPrivateFieldGet,\r\n    __classPrivateFieldSet,\r\n    __classPrivateFieldIn,\r\n};\r\n", "import { splitComma, splitBracket, splitUnit, splitSpace, isArray, convertUnitSize, isObject } from \"@daybrush/utils\";\nimport { MatrixInfo } from \"./types\";\nimport { calculate, invert, matrix3d, rotateX3d, rotateY3d, rotateZ3d, scale3d, translate3d } from \"@scena/matrix\";\n\nexport function createMatrix() {\n    return [\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0,\n        0, 0, 0, 1,\n    ];\n}\nexport function parseMat(transform: string | string[], size: number | Record<string, ((pos: number) => number) | number> = 0): number[] {\n    return toMat(parse(transform, size));\n}\nexport function getElementMatrix(el: HTMLElement) {\n    return parseMat(getComputedStyle(el).transform!);\n}\nexport function calculateMatrixDist(matrix: number[], pos: number[]) {\n    const res = calculate(matrix, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);\n    const w = res[3] || 1;\n\n    return [\n        res[0] / w,\n        res[1] / w,\n        res[2] / w,\n    ];\n}\nexport function getDistElementMatrix(el: HTMLElement, container = document.body): number[] {\n    let target: HTMLElement | null = el;\n    let matrix = createMatrix();\n\n    while (target) {\n        const transform = getComputedStyle(target).transform!;\n        matrix = matrix3d(parseMat(transform), matrix);\n\n        if (target === container) {\n            break;\n        }\n        target = target.parentElement;\n    }\n    matrix = invert(matrix, 4);\n\n    matrix[12] = 0;\n    matrix[13] = 0;\n    matrix[14] = 0;\n\n    return matrix;\n}\n\nexport function toMat(matrixInfos: MatrixInfo[]): number[] {\n    let target = createMatrix();\n\n    matrixInfos.forEach(info => {\n        const {\n            matrixFunction,\n            functionValue,\n        } = info;\n\n        if (!matrixFunction) {\n            return;\n        }\n        target = matrixFunction(target, functionValue);\n    });\n    return target;\n}\nexport function parse(transform: string | string[], size: number | Record<string, ((pos: number) => number) | number> = 0): MatrixInfo[] {\n    const transforms = isArray(transform) ? transform : splitSpace(transform);\n\n    return transforms.map(t => {\n        const { prefix: name, value } = splitBracket(t);\n\n\n        let matrixFunction = null;\n        let functionName: string = name;\n        let functionValue: any = \"\";\n\n        if (name === \"translate\" || name === \"translateX\" || name === \"translate3d\") {\n            const nextSize = isObject(size) ? {\n                ...size,\n                \"o%\": size[\"%\"],\n            } : {\n                \"%\": size,\n                \"o%\": size,\n            };\n            const [posX, posY = 0, posZ = 0] = splitComma(value!).map((v, i) => {\n                if (i === 0 && \"x%\" in nextSize) {\n                    nextSize[\"%\"] = size[\"x%\"];\n                } else if (i === 1 && \"y%\" in nextSize) {\n                    nextSize[\"%\"] = size[\"y%\"];\n                } else {\n                    nextSize[\"%\"] = size[\"o%\"];\n                }\n                return convertUnitSize(v, nextSize);\n            });\n\n            matrixFunction = translate3d;\n            functionValue = [posX, posY, posZ];\n        } else if (name === \"translateY\") {\n            const nextSize = isObject(size) ? {\n                \"%\": size[\"y%\"],\n                ...size,\n            } : {\n                \"%\": size,\n            };\n            const posY = convertUnitSize(value!, nextSize);\n\n            matrixFunction = translate3d;\n            functionValue = [0, posY, 0];\n        } else if (name === \"translateZ\") {\n            const posZ = parseFloat(value!);\n\n            matrixFunction = translate3d;\n            functionValue = [0, 0, posZ];\n        } else if (name === \"scale\" || name === \"scale3d\") {\n            const [sx, sy = sx, sz = 1] = splitComma(value!).map(v => parseFloat(v)) as number[];\n\n            matrixFunction = scale3d;\n            functionValue = [sx, sy, sz];\n        } else if (name === \"scaleX\") {\n            const sx = parseFloat(value!);\n\n            matrixFunction = scale3d;\n            functionValue = [sx, 1, 1];\n        } else if (name === \"scaleY\") {\n            const sy = parseFloat(value!);\n\n            matrixFunction = scale3d;\n            functionValue = [1, sy, 1];\n        } else if (name === \"scaleZ\") {\n            const sz = parseFloat(value!);\n\n            matrixFunction = scale3d;\n            functionValue = [1, 1, sz];\n        } else if (name === \"rotate\" || name === \"rotateZ\" || name === \"rotateX\" || name === \"rotateY\") {\n            const { unit, value: unitValue } = splitUnit(value!);\n            const rad = unit === \"rad\" ? unitValue : unitValue * Math.PI / 180;\n\n            if (name === \"rotate\" || name === \"rotateZ\") {\n                functionName = \"rotateZ\";\n                matrixFunction = rotateZ3d;\n            } else if (name === \"rotateX\") {\n                matrixFunction = rotateX3d;\n            } else if (name === \"rotateY\") {\n                matrixFunction = rotateY3d;\n            }\n            functionValue = rad;\n        } else if (name === \"matrix3d\") {\n            matrixFunction = matrix3d;\n            functionValue = splitComma(value!).map(v => parseFloat(v));\n        } else if (name === \"matrix\") {\n            const m = splitComma(value!).map(v => parseFloat(v));\n            matrixFunction = matrix3d;\n            functionValue = [\n                m[0], m[1], 0, 0,\n                m[2], m[3], 0, 0,\n                0, 0, 1, 0,\n                m[4], m[5], 0, 1,\n            ];\n        } else {\n            functionName = \"\";\n        }\n        return {\n            name: name!,\n            functionName,\n            value: value!,\n            matrixFunction,\n            functionValue,\n        };\n    });\n}\n", "import stringHash from \"string-hash\";\nimport { getDocument, splitComma } from \"@daybrush/utils\";\nimport { InjectOptions } from \"./types\";\n\nexport function getHash(str: string) {\n    return stringHash(str).toString(36);\n}\nexport function getShadowRoot(parentElement: HTMLElement | SVGElement) {\n    if (parentElement && parentElement.getRootNode) {\n        const rootNode = parentElement.getRootNode();\n\n        if (rootNode.nodeType === 11) {\n            return rootNode as ShadowRoot;\n        }\n    }\n    return;\n}\nexport function replaceStyle(className: string, css: string, options: Partial<InjectOptions>) {\n    if (options.original) {\n        return css;\n    }\n    return css.replace(/([^};{\\s}][^};{]*|^\\s*){/mg, (_, selector) => {\n        const trimmedSelector = selector.trim();\n        return (trimmedSelector ? splitComma(trimmedSelector) : [\"\"]).map(subSelector => {\n            const trimmedSubSelector = subSelector.trim();\n            if (trimmedSubSelector.indexOf(\"@\") === 0) {\n                return trimmedSubSelector;\n            } else if (trimmedSubSelector.indexOf(\":global\") > -1) {\n                return trimmedSubSelector.replace(/\\:global/g, \"\");\n            } else if (trimmedSubSelector.indexOf(\":host\") > -1) {\n                return `${trimmedSubSelector.replace(/\\:host/g, `.${className}`)}`;\n            } else if (trimmedSubSelector) {\n                return `.${className} ${trimmedSubSelector}`;\n            } else {\n                return `.${className}`;\n            }\n        }).join(\", \") + \" {\";\n    });\n}\nexport function injectStyle(className: string, css: string, options: Partial<InjectOptions>, el: Node, shadowRoot?: Node) {\n    const doc = getDocument(el);\n    const style = doc.createElement(\"style\");\n\n    style.setAttribute(\"type\", \"text/css\");\n    style.setAttribute(\"data-styled-id\", className);\n    style.setAttribute(\"data-styled-count\", \"1\");\n\n    if (options.nonce) {\n        style.setAttribute(\"nonce\", options.nonce);\n    }\n    style.innerHTML = replaceStyle(className, css, options);\n\n    (shadowRoot || doc.head || doc.body).appendChild(style);\n    return style;\n}\n", "import { getHash, injectStyle, getShadowRoot } from \"./utils\";\nimport { StyledInjector, InjectOptions } from \"./types\";\n\n/**\n * Create an styled object that can be defined and inserted into the css.\n * @param - css styles\n */\nfunction styled(css: string): StyledInjector {\n    const injectClassName = \"rCS\" + getHash(css);\n\n    return {\n        className: injectClassName,\n        inject(el: HTMLElement | SVGElement, options: Partial<InjectOptions> = {}) {\n            const shadowRoot = getShadowRoot(el);\n            let styleElement = (shadowRoot || el.ownerDocument || document).querySelector<HTMLStyleElement>(`style[data-styled-id=\"${injectClassName}\"]`);\n\n            if (!styleElement) {\n                styleElement = injectStyle(injectClassName, css, options, el, shadowRoot);\n            } else {\n                const count = parseFloat(styleElement.getAttribute(\"data-styled-count\")) || 0;\n                styleElement.setAttribute(\"data-styled-count\", `${count + 1}`);\n            }\n            return {\n                destroy() {\n                    const injectCount = parseFloat(styleElement.getAttribute(\"data-styled-count\")) || 0;\n\n                    if (injectCount <= 1) {\n                        if (styleElement.remove) {\n                            styleElement.remove();\n                        } else {\n                            styleElement.parentNode?.removeChild(styleElement);\n                        }\n                        styleElement = null;\n                    } else {\n                        styleElement.setAttribute(\"data-styled-count\", `${injectCount - 1}`);\n                    }\n                },\n            };\n        },\n    };\n}\n\nexport * from \"./types\";\nexport default styled;\n", "import type { ElementType, Hypertext, Point, Rect } from \"./types\";\nimport { IObject, addClass, hasClass, calculateBoundSize, getDist, getDocument } from \"@daybrush/utils\";\nimport { diff } from \"@egjs/children-differ\";\nimport { getMinMaxs } from \"overlap-area\";\n\nexport function getClient(e: MouseEvent | TouchEvent) {\n    if (\"touches\" in e) {\n        const touch = e.touches[0] || e.changedTouches[0];\n\n        return {\n            clientX: touch.clientX,\n            clientY: touch.clientY,\n        };\n    } else {\n        return {\n            clientX: e.clientX,\n            clientY: e.clientY,\n        };\n    }\n}\nexport function filterDuplicated<T>(arr: T[]): T[] {\n    if (typeof Map === \"undefined\") {\n        return arr.filter((value, index) => {\n            return arr.indexOf(value) === index;\n        });\n    }\n    const map = new Map<T, true>();\n    return arr.filter(value => {\n        if (map.has(value)) {\n            return false;\n        }\n        map.set(value, true);\n        return true;\n    });\n}\n\nexport function elementFromPoint(baseNode: Node, clientX: number, clientY: number): ElementType | null {\n    const doc = getDocument(baseNode);\n\n    return (doc.elementFromPoint && doc.elementFromPoint(clientX, clientY)) as any || null;\n}\n\nexport function createElement(\n    jsx: Hypertext,\n    prevTarget?: ElementType,\n    container?: ElementType,\n) {\n    const { tag, children, attributes, className, style } = jsx;\n    const el = prevTarget || getDocument(container).createElement(tag) as ElementType;\n\n    for (const name in attributes) {\n        el.setAttribute(name, attributes[name]);\n    }\n    const elChildren = el.children;\n    children.forEach((child, i) => {\n        createElement(child, elChildren[i] as ElementType, el);\n    });\n    if (className) {\n        className.split(/\\s+/g).forEach(name => {\n            if (name && !hasClass(el, name)) {\n                addClass(el, name);\n            }\n        });\n    }\n    if (style) {\n        const elStyle = el.style;\n        for (const name in style) {\n            elStyle[name] = style[name];\n        }\n    }\n    if (!prevTarget && container) {\n        container.appendChild(el);\n    }\n    return el;\n}\nexport function h(\n    tag: string,\n    attrs: IObject<any>,\n    ...children: Hypertext[]\n): Hypertext {\n    const {\n        className = \"\",\n        style = {},\n        ...attributes\n    } = attrs || {};\n    return {\n        tag,\n        className,\n        style,\n        attributes,\n        children,\n    };\n}\n\nexport function diffValue<T>(prev: T, cur: T, func: (prev: T, cur: T) => void) {\n    if (prev !== cur) {\n        func(prev, cur);\n    }\n}\nexport function isFastInside(point: number[], points: number[][]) {\n    const { minX, minY, maxX, maxY } = getMinMaxs(points);\n    const [x, y] = point;\n\n    return minX <= x && x <= maxX && minY <= y && y <= maxY;\n}\nexport function getFastOverlapPoints(points1: number[][], points2: number[][]) {\n    const {\n        minX: minX1,\n        minY: minY1,\n        maxX: maxX1,\n        maxY: maxY1,\n    } = getMinMaxs(points1);\n    const {\n        minX: minX2,\n        minY: minY2,\n        maxX: maxX2,\n        maxY: maxY2,\n    } = getMinMaxs(points2);\n\n    if (maxX2 < minX1 || maxX1 < minX2 || maxY2 < minY1 || maxY1 < minY2) {\n        return [];\n    }\n    const width = Math.min(maxX2 - minX1, maxX1 - minX2);\n    const height = Math.min(maxY2 - minY1, maxY1 - minY2);\n\n    return [\n        [0, 0],\n        [width, 0],\n        [width, height],\n        [0, height],\n    ];\n}\nexport function getRect(\n    e: any, ratio: number,\n    boundArea = e.data.boundArea,\n): Rect {\n    let {\n        distX = 0,\n        distY = 0,\n    } = e;\n    const { startX, startY } = e.data;\n\n    if (ratio > 0) {\n        const nextHeight = Math.sqrt((distX * distX + distY * distY) / (1 + ratio * ratio));\n        const nextWidth = ratio * nextHeight;\n\n        distX = (distX >= 0 ? 1 : -1) * nextWidth;\n        distY = (distY >= 0 ? 1 : -1) * nextHeight;\n    }\n    let width = Math.abs(distX);\n    let height = Math.abs(distY);\n\n    const maxWidth = distX < 0 ? startX - boundArea.left : boundArea.right - startX;\n    const maxHeight = distY < 0 ? startY - boundArea.top : boundArea.bottom - startY;\n\n    [width, height] = calculateBoundSize([width, height], [0, 0], [maxWidth, maxHeight], !!ratio);\n    distX = (distX >= 0 ? 1 : -1) * width;\n    distY = (distY >= 0 ? 1 : -1) * height;\n\n    const tx = Math.min(0, distX);\n    const ty = Math.min(0, distY);\n    const left = startX + tx;\n    const top = startY + ty;\n\n    return {\n        left,\n        top,\n        right: left + width,\n        bottom: top + height,\n        width,\n        height,\n    };\n}\n\nexport function getDefaultElementRect(el: ElementType): Point {\n    const rect = el.getBoundingClientRect();\n    const { left, top, width, height } = rect;\n\n    return {\n        pos1: [left, top],\n        pos2: [left + width, top],\n        pos3: [left, top + height],\n        pos4: [left + width, top + height],\n    };\n}\n\nexport function passTargets(\n    beforeTargets: ElementType[],\n    afterTargets: ElementType[],\n    continueSelectWithoutDeselect: boolean,\n) {\n    const {\n        list,\n        prevList,\n        added,\n        removed,\n        maintained,\n    } = diff(beforeTargets, afterTargets);\n\n    return [\n        ...added.map(index => list[index]),\n        ...removed.map(index => prevList[index]),\n        ...continueSelectWithoutDeselect ? maintained.map(([, nextIndex]) => list[nextIndex]) : [],\n    ];\n}\n\nexport function getLineSize(points: number[][]) {\n    let size = 0;\n    const length = points.length;\n\n    for (let i = 1; i < length; ++i) {\n        size = Math.max(getDist(points[i], points[i - 1]), size);\n    }\n\n    return size;\n}\n", "import styled from \"css-styled\";\nimport { SelectoOptions } from \"./types\";\n\nexport const injector = styled(`\n:host {\n    position: fixed;\n    display: none;\n    border: 1px solid #4af;\n    background: rgba(68, 170, 255, 0.5);\n    pointer-events: none;\n    will-change: transform;\n    z-index: 100;\n}\n`);\n\n/**\n * @memberof Selecto\n */\nexport const CLASS_NAME = `selecto-selection ${injector.className}`;\n\nexport const PROPERTIES = [\n    \"className\",\n    \"boundContainer\",\n    \"selectableTargets\",\n    \"selectByClick\",\n    \"selectFromInside\",\n    \"continueSelect\",\n    \"continueSelectWithoutDeselect\",\n    \"toggleContinueSelect\",\n    \"toggleContinueSelectWithoutDeselect\",\n    \"keyContainer\",\n    \"hitRate\",\n    \"scrollOptions\",\n    \"checkInput\",\n    \"preventDefault\",\n    \"ratio\",\n    \"getElementRect\",\n    \"preventDragFromInside\",\n    \"rootContainer\",\n    \"dragCondition\",\n    \"clickBySelectEnd\",\n    \"checkOverflow\",\n    \"innerScrollOptions\",\n] as const;\n/**\n * @memberof Selecto\n */\nexport const OPTIONS = [\n    // ignore target, container,\n    \"dragContainer\",\n    \"cspNonce\",\n    \"preventClickEventOnDrag\",\n    \"preventClickEventOnDragStart\",\n    \"preventRightClick\",\n    ...PROPERTIES,\n] as const;\n\nexport const OPTION_TYPES: { [key in keyof SelectoOptions]: any } = {\n    className: String,\n    boundContainer: null,\n    portalContainer: null,\n    container: null,\n    dragContainer: null,\n    selectableTargets: Array,\n    selectByClick: Boolean,\n    selectFromInside: Boolean,\n    continueSelect: Boolean,\n    toggleContinueSelect: Array,\n    toggleContinueSelectWithoutDeselect: Array,\n    keyContainer: null,\n    hitRate: Number,\n    scrollOptions: Object,\n    checkInput: Boolean,\n    preventDefault: Boolean,\n    cspNonce: String,\n    ratio: Number,\n    getElementRect: Function,\n    preventDragFromInside: Boolean,\n    rootContainer: Object,\n    dragCondition: Function,\n    clickBySelectEnd: Boolean,\n    continueSelectWithoutDeselect: Boolean,\n    preventClickEventOnDragStart: Boolean,\n    preventClickEventOnDrag: Boolean,\n    checkOverflow: Boolean,\n    innerScrollOptions: Object,\n};\n\n/**\n * @memberof Selecto\n */\nexport const EVENTS = [\n    \"dragStart\",\n    \"drag\",\n    \"dragEnd\",\n    \"selectStart\",\n    \"select\",\n    \"selectEnd\",\n    \"keydown\",\n    \"keyup\",\n    \"scroll\",\n    \"innerScroll\",\n] as const;\n\n/**\n * @memberof Selecto\n */\nexport const METHODS = [\n    \"clickTarget\",\n    \"getSelectableElements\",\n    \"setSelectedTargets\",\n    \"getElementPoints\",\n    \"getSelectedTargets\",\n    \"findSelectableTargets\",\n    \"triggerDragStart\",\n    \"checkScroll\",\n    \"selectTargetsByPoints\",\n    \"setSelectedTargetsByPoints\",\n] as const;\n", "import EventEmitter from \"@scena/event-emitter\";\nimport Gesto, { OnDrag } from \"gesto\";\nimport { InjectResult } from \"css-styled\";\nimport { Properties } from \"framework-utils\";\nimport {\n    isObject,\n    camelize,\n    IObject,\n    addEvent,\n    removeEvent,\n    isArray,\n    isString,\n    between,\n    splitUnit,\n    isFunction,\n    getWindow,\n    getDocument,\n    isNode,\n} from \"@daybrush/utils\";\nimport { diff } from \"@egjs/children-differ\";\nimport DragScroll from \"@scena/dragscroll\";\nimport KeyController, { KeyControllerEvent, getCombi } from \"keycon\";\nimport {\n    getAreaSize,\n    getOverlapPoints,\n    isInside,\n    fitPoints,\n} from \"overlap-area\";\nimport { getDistElementMatrix, calculateMatrixDist, createMatrix } from \"css-to-mat\";\nimport {\n    createElement,\n    h,\n    getClient,\n    diffValue,\n    getRect,\n    getDefaultElementRect,\n    passTargets,\n    elementFromPoint,\n    filterDuplicated,\n    getLineSize,\n} from \"./utils\";\nimport {\n    SelectoOptions,\n    SelectoProperties,\n    OnDragEvent,\n    SelectoEvents,\n    Rect,\n    BoundContainer,\n    SelectedTargets,\n    SelectedTargetsWithRect,\n    InnerParentInfo,\n    ElementType,\n    OnDragStart,\n} from \"./types\";\nimport { PROPERTIES, injector, CLASS_NAME } from \"./consts\";\n\n/**\n * Selecto.js is a component that allows you to select elements in the drag area using the mouse or touch.\n * @sort 1\n * @extends EventEmitter\n */\n@Properties(PROPERTIES as any, (prototype, property) => {\n    const attributes: IObject<any> = {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return this.options[property];\n        },\n    };\n    const getter = camelize(`get ${property}`);\n    if (prototype[getter]) {\n        attributes.get = function() {\n            return this[getter]();\n        };\n    } else {\n        attributes.get = function() {\n            return this.options[property];\n        };\n    }\n    const setter = camelize(`set ${property}`);\n    if (prototype[setter]) {\n        attributes.set = function(value: any) {\n            this[setter](value);\n        };\n    } else {\n        attributes.set = function(value: any) {\n            this.options[property] = value;\n        };\n    }\n    Object.defineProperty(prototype, property, attributes);\n})\n\nclass Selecto extends EventEmitter<SelectoEvents> {\n    public options: SelectoOptions;\n    private target!: ElementType;\n    private dragContainer!: Element | Window | Element[];\n    private container!: HTMLElement;\n    private gesto!: Gesto;\n    private injectResult!: InjectResult;\n    private selectedTargets: ElementType[] = [];\n    private dragScroll: DragScroll = new DragScroll();\n    private keycon!: KeyController;\n    private _keydownContinueSelect: boolean;\n    private _keydownContinueSelectWithoutDeselection: boolean;\n    /**\n     *\n     */\n    constructor(options: Partial<SelectoOptions> = {}) {\n        super();\n        this.target = options.portalContainer;\n        let container = options.container;\n        this.options = {\n            className: \"\",\n            portalContainer: null,\n            container: null,\n            dragContainer: null,\n            selectableTargets: [],\n            selectByClick: true,\n            selectFromInside: true,\n            clickBySelectEnd: false,\n            hitRate: 100,\n            continueSelect: false,\n            continueSelectWithoutDeselect: false,\n            toggleContinueSelect: null,\n            toggleContinueSelectWithoutDeselect: null,\n            keyContainer: null,\n            scrollOptions: null,\n            checkInput: false,\n            preventDefault: false,\n            boundContainer: false,\n            preventDragFromInside: true,\n            dragCondition: null,\n            rootContainer: null,\n            checkOverflow: false,\n            innerScrollOptions: false,\n            getElementRect: getDefaultElementRect,\n            cspNonce: \"\",\n            ratio: 0,\n            ...options,\n        };\n        const portalContainer = this.options.portalContainer;\n\n        if (portalContainer) {\n            container = portalContainer.parentElement;\n        }\n        this.container = container || document.body;\n        this.initElement();\n        this.initDragScroll();\n        this.setKeyController();\n    }\n    /**\n     * You can set the currently selected targets.\n     * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n     */\n    public setSelectedTargets(\n        selectedTargets: ElementType[],\n    ): SelectedTargets {\n        const beforeSelected = this.selectedTargets;\n        const { added, removed, prevList, list } = diff(\n            beforeSelected,\n            selectedTargets\n        );\n        this.selectedTargets = selectedTargets;\n\n        return {\n            added: added.map(index => list[index]),\n            removed: removed.map(index => prevList[index]),\n            beforeSelected,\n            selected: selectedTargets,\n        };\n    }\n    /**\n     * You can set the currently selected targets by points\n     * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n     */\n    public setSelectedTargetsByPoints(\n        point1: number[],\n        point2: number[],\n    ): SelectedTargetsWithRect {\n        const left = Math.min(point1[0], point2[0]);\n        const top = Math.min(point1[1], point2[1]);\n        const right = Math.max(point1[0], point2[0]);\n        const bottom = Math.max(point1[1], point2[1]);\n        const rect: Rect = {\n            left,\n            top,\n            right,\n            bottom,\n            width: right - left,\n            height: bottom - top,\n        };\n        const data = { ignoreClick: true };\n\n        this.findSelectableTargets(data);\n        const selectedElements = this.hitTest(rect, data, true, null);\n        const result = this.setSelectedTargets(selectedElements);\n\n        return {\n            ...result,\n            rect,\n        };\n    }\n    /**\n     * Select target by virtual drag from startPoint to endPoint.\n     * The target of inputEvent is null.\n     */\n    public selectTargetsByPoints(\n        startPoint: number[],\n        endPoint: number[],\n    ) {\n        const mousedown = new MouseEvent(\"mousedown\", {\n            clientX: startPoint[0],\n            clientY: startPoint[1],\n            cancelable: true,\n            bubbles: true,\n        });\n        const mousemove = new MouseEvent(\"mousemove\", {\n            clientX: endPoint[0],\n            clientY: endPoint[1],\n            cancelable: true,\n            bubbles: true,\n        });\n        const mouseup = new MouseEvent(\"mousemove\", {\n            clientX: endPoint[0],\n            clientY: endPoint[1],\n            cancelable: true,\n            bubbles: true,\n        });\n        const gesto = this.gesto;\n        const result = gesto.onDragStart(mousedown);\n\n        if (result !== false) {\n            gesto.onDrag(mousemove);\n            gesto.onDragEnd(mouseup);\n        }\n    }\n    /**\n     * You can get the currently selected targets.\n     */\n    public getSelectedTargets(): ElementType[] {\n        return this.selectedTargets;\n    }\n    /**\n     * `OnDragStart` is triggered by an external event.\n     * @param - external event\n     * @example\n     * import Selecto from \"selecto\";\n     *\n     * const selecto = new Selecto();\n     *\n     * window.addEventListener(\"mousedown\", e => {\n     *   selecto.triggerDragStart(e);\n     * });\n     */\n    public triggerDragStart(e: MouseEvent | TouchEvent) {\n        this.gesto.triggerDragStart(e);\n        return this;\n    }\n    /**\n     * Destroy elements, properties, and events.\n     */\n    public destroy() {\n        this.off();\n        this.keycon && this.keycon.destroy();\n        this.gesto.unset();\n        this.injectResult.destroy();\n        this.dragScroll.dragEnd();\n        removeEvent(document, \"selectstart\", this._onDocumentSelectStart);\n\n        if (!this.options.portalContainer) {\n            this.target.parentElement?.removeChild(this.target);\n        }\n\n\n        this.keycon = null;\n        this.gesto = null;\n        this.injectResult = null;\n        this.target = null;\n        this.container = null;\n        this.options = null;\n    }\n    public getElementPoints(target: ElementType) {\n        const getElementRect = this.getElementRect || getDefaultElementRect;\n        const info = getElementRect(target);\n        const points = [info.pos1, info.pos2, info.pos4, info.pos3];\n\n        if (getElementRect !== getDefaultElementRect) {\n            const rect = target.getBoundingClientRect();\n\n            return fitPoints(points, rect);\n        }\n        return points;\n    }\n    /**\n     * Get all elements set in `selectableTargets`.\n     */\n    public getSelectableElements() {\n        const container = this.container;\n        const selectableElements: ElementType[] = [];\n\n        this.options.selectableTargets.forEach((target) => {\n            if (isFunction(target)) {\n                const result = target();\n\n                if (result) {\n                    selectableElements.push(...[].slice.call(result));\n                }\n            } else if (isNode(target)) {\n                selectableElements.push(target);\n            } else if (isObject(target)) {\n                selectableElements.push(target.value || target.current);\n            } else {\n                const elements = [].slice.call(\n                    (getDocument(container)).querySelectorAll(target)\n                );\n\n                selectableElements.push(...elements);\n            }\n        });\n\n        return selectableElements;\n    }\n    /**\n     * If scroll occurs during dragging, you can manually call this method to check the position again.\n     */\n    public checkScroll() {\n        if (!this.gesto.isFlag()) {\n            return;\n        }\n        const scrollOptions = this.scrollOptions;\n        const innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n        const hasScrollOptions = innerScrollOptions || scrollOptions?.container;\n\n        // If it is a scrolling position, pass drag\n        if (hasScrollOptions) {\n            this.dragScroll.checkScroll({\n                inputEvent: this.gesto.getCurrentEvent(),\n                ...(innerScrollOptions || scrollOptions),\n            });\n        }\n    }\n    /**\n     * Find for selectableTargets again during drag event\n     * You can update selectable targets during an event.\n     */\n    public findSelectableTargets(data: IObject<any> = this.gesto.getEventData()) {\n        const selectableTargets = this.getSelectableElements();\n        const selectablePoints = selectableTargets.map(\n            (target) => this.getElementPoints(target),\n        );\n\n        data.selectableTargets = selectableTargets;\n        data.selectablePoints = selectablePoints;\n        data.selectableParentMap = null;\n\n        const options = this.options;\n        const hasIndexesMap = options.checkOverflow || options.innerScrollOptions;\n        const doc = getDocument(this.container);\n\n        if (hasIndexesMap) {\n            const parentMap = new Map<Element, InnerParentInfo>();\n\n            data.selectableInnerScrollParentMap = parentMap;\n            data.selectableInnerScrollPathsList = selectableTargets.map((target, index) => {\n                let parentElement = target.parentElement;\n\n                let parents: Element[] = [];\n                const paths: Element[] = [];\n\n                while (parentElement && parentElement !== doc.body) {\n                    let info: InnerParentInfo = parentMap.get(parentElement);\n\n                    if (!info) {\n                        const overflow = getComputedStyle(parentElement).overflow !== \"visible\";\n\n                        if (overflow) {\n                            const rect = getDefaultElementRect(parentElement);\n\n                            info = {\n                                parentElement,\n                                indexes: [],\n                                points: [rect.pos1, rect.pos2, rect.pos4, rect.pos3],\n                                paths: [...paths],\n                            };\n\n                            parents.push(parentElement);\n                            parents.forEach(prevParentElement => {\n                                parentMap.set(prevParentElement, info);\n                            });\n                            parents = [];\n                        }\n                    }\n                    if (info) {\n                        parentElement = info.parentElement;\n\n                        parentMap.get(parentElement).indexes.push(index);\n                        paths.push(parentElement);\n                    } else {\n                        parents.push(parentElement);\n                    }\n                    parentElement = parentElement.parentElement;\n                }\n\n                return paths;\n            });\n        }\n\n        if (!options.checkOverflow) {\n            data.selectableInners = selectableTargets.map(() => true);\n        }\n\n        this._refreshGroups(data);\n\n        return selectableTargets;\n    }\n    /**\n     * External click or mouse events can be applied to the selecto.\n     * @params - Extenal click or mouse event\n     * @params - Specify the clicked target directly.\n     */\n    public clickTarget(\n        e: MouseEvent | TouchEvent,\n        clickedTarget?: Element\n    ): this {\n        const { clientX, clientY } = getClient(e);\n        const dragEvent = {\n            data: {\n                selectFlag: false,\n            },\n            clientX,\n            clientY,\n            inputEvent: e,\n            isClick: true,\n            isTrusted: false,\n            stop: () => {\n                return false;\n            },\n        } as any;\n        if (this._onDragStart(dragEvent, clickedTarget)) {\n            this._onDragEnd(dragEvent);\n        }\n        return this;\n    }\n    private setKeyController() {\n        const { keyContainer, toggleContinueSelect, toggleContinueSelectWithoutDeselect } = this.options;\n\n        if (this.keycon) {\n            this.keycon.destroy();\n            this.keycon = null;\n        }\n        if (toggleContinueSelect || toggleContinueSelectWithoutDeselect) {\n            this.keycon = new KeyController(keyContainer || getWindow(this.container));\n            this.keycon\n                .keydown(this._onKeyDown)\n                .keyup(this._onKeyUp)\n                .on(\"blur\", this._onBlur);\n        }\n    }\n    private setClassName(nextClassName: string) {\n        this.options.className = nextClassName;\n        this.target.setAttribute(`class`, `${CLASS_NAME} ${nextClassName || \"\"}`);\n    }\n    private setKeyEvent() {\n        const { toggleContinueSelect, toggleContinueSelectWithoutDeselect } = this.options;\n        if ((!toggleContinueSelect && !toggleContinueSelectWithoutDeselect) || this.keycon) {\n            return;\n        }\n        this.setKeyController();\n    }\n    // with getter, setter property\n    private setKeyContainer(keyContainer: HTMLElement | Document | Window) {\n        const options = this.options;\n\n        diffValue(options.keyContainer, keyContainer, () => {\n            options.keyContainer = keyContainer;\n\n            this.setKeyController();\n        });\n    }\n    private getContinueSelect() {\n        const {\n            continueSelect,\n            toggleContinueSelect,\n        } = this.options;\n\n        if (!toggleContinueSelect || !this._keydownContinueSelect) {\n            return continueSelect;\n        }\n        return !continueSelect;\n    }\n    private getContinueSelectWithoutDeselect() {\n        const {\n            continueSelectWithoutDeselect,\n            toggleContinueSelectWithoutDeselect,\n        } = this.options;\n\n        if (!toggleContinueSelectWithoutDeselect || !this._keydownContinueSelectWithoutDeselection) {\n            return continueSelectWithoutDeselect;\n        }\n        return !continueSelectWithoutDeselect;\n    }\n    private setToggleContinueSelect(\n        toggleContinueSelect: string[][] | string[] | string\n    ) {\n        const options = this.options;\n\n        diffValue(options.toggleContinueSelect, toggleContinueSelect, () => {\n            options.toggleContinueSelect = toggleContinueSelect;\n\n            this.setKeyEvent();\n        });\n    }\n    private setToggleContinueSelectWithoutDeselect(\n        toggleContinueSelectWithoutDeselect: string[][] | string[] | string\n    ) {\n        const options = this.options;\n\n        diffValue(options.toggleContinueSelectWithoutDeselect, toggleContinueSelectWithoutDeselect, () => {\n            options.toggleContinueSelectWithoutDeselect = toggleContinueSelectWithoutDeselect;\n\n            this.setKeyEvent();\n        });\n    }\n    private setPreventDefault(value: boolean) {\n        this.gesto.options.preventDefault = value;\n    }\n    private setCheckInput(value: boolean) {\n        this.gesto.options.checkInput = value;\n    }\n    private initElement() {\n        const {\n            dragContainer,\n            checkInput,\n            preventDefault,\n            preventClickEventOnDragStart,\n            preventClickEventOnDrag,\n            preventClickEventByCondition,\n            preventRightClick = true,\n            className,\n        } = this.options;\n        const container = this.container;\n\n        this.target = createElement(\n            (<div className={`${CLASS_NAME} ${className || \"\"}`}></div>) as any,\n            this.target,\n            container,\n        );\n\n\n        const target = this.target;\n\n        this.dragContainer =\n            typeof dragContainer === \"string\"\n                ? [].slice.call(getDocument(container).querySelectorAll(dragContainer))\n                : dragContainer || (this.target.parentNode as any);\n        this.gesto = new Gesto(this.dragContainer, {\n            checkWindowBlur: true,\n            container: getWindow(container),\n            checkInput,\n            preventDefault,\n            preventClickEventOnDragStart,\n            preventClickEventOnDrag,\n            preventClickEventByCondition,\n            preventRightClick,\n        }).on({\n            dragStart: this._onDragStart,\n            drag: this._onDrag,\n            dragEnd: this._onDragEnd,\n        });\n        addEvent(document, \"selectstart\", this._onDocumentSelectStart);\n\n        this.injectResult = injector.inject(target, {\n            nonce: this.options.cspNonce,\n        });\n    }\n    private hitTest(\n        selectRect: Rect,\n        data: any,\n        isDrag: boolean,\n        gestoEvent: any,\n    ) {\n        const { hitRate, selectByClick } = this.options;\n        const { left, top, right, bottom } = selectRect;\n        const innerGroups: Record<string | number, Record<string | number, number[]>> = data.innerGroups;\n        const innerWidth = data.innerWidth;\n        const innerHeight = data.innerHeight;\n        const clientX = gestoEvent?.clientX;\n        const clientY = gestoEvent?.clientY;\n        const ignoreClick = data.ignoreClick;\n        const rectPoints = [\n            [left, top],\n            [right, top],\n            [right, bottom],\n            [left, bottom],\n        ];\n        const isHit = (points: number[][], el: Element) => {\n            const hitRateValue =\n                typeof hitRate === \"function\"\n                    ? splitUnit(`${hitRate(el)}`)\n                    : splitUnit(`${hitRate}`);\n\n            const inArea = ignoreClick\n                ? false\n                : isInside([clientX, clientY], points);\n\n            if (!isDrag && selectByClick && inArea) {\n                return true;\n            }\n            const overlapPoints = getOverlapPoints(rectPoints, points);\n\n            if (!overlapPoints.length) {\n                return false;\n            }\n            let overlapSize = getAreaSize(overlapPoints);\n\n            // Line\n            let targetSize = 0;\n\n            if (overlapSize === 0 && getAreaSize(points) === 0) {\n                targetSize = getLineSize(points);\n                overlapSize = getLineSize(overlapPoints);\n            } else {\n                targetSize = getAreaSize(points);\n            }\n\n\n            if (hitRateValue.unit === \"px\") {\n                return overlapSize >= hitRateValue.value;\n            } else {\n                const rate = between(\n                    Math.round((overlapSize / targetSize) * 100),\n                    0,\n                    100\n                );\n\n                return rate >= Math.min(100, hitRateValue.value);\n            }\n        };\n        const selectableTargets: ElementType[] = data.selectableTargets;\n        const selectablePoints: number[][][] = data.selectablePoints;\n        const selectableInners: boolean[] = data.selectableInners;\n\n        if (!innerGroups) {\n            return selectableTargets.filter((_, i) => {\n                if (!selectableInners[i]) {\n                    return false;\n                }\n                return isHit(selectablePoints[i], selectableTargets[i]);\n            });\n        }\n        const selectedTargets: ElementType[] = [];\n        const minX = Math.floor(left / innerWidth);\n        const maxX = Math.floor(right / innerWidth);\n        const minY = Math.floor(top / innerHeight);\n        const maxY = Math.floor(bottom / innerHeight);\n\n        for (let x = minX; x <= maxX; ++x) {\n            const yGroups = innerGroups[x];\n\n            if (!yGroups) {\n                continue;\n            }\n            for (let y = minY; y <= maxY; ++y) {\n                const group = yGroups[y];\n\n                if (!group) {\n                    continue;\n                }\n                group.forEach(index => {\n                    const points = selectablePoints[index];\n                    const inner = selectableInners[index];\n                    const target = selectableTargets[index];\n\n                    if (inner && isHit(points, target)) {\n                        selectedTargets.push(target);\n                    }\n                });\n            }\n        }\n        return filterDuplicated(selectedTargets);\n    }\n    private initDragScroll() {\n        this.dragScroll\n            .on(\"scrollDrag\", ({ next }) => {\n                next(this.gesto.getCurrentEvent());\n            })\n            .on(\"scroll\", ({ container, direction }) => {\n                const innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n\n                if (innerScrollOptions) {\n                    this.emit(\"innerScroll\", {\n                        container,\n                        direction,\n                    });\n                } else {\n                    this.emit(\"scroll\", {\n                        container,\n                        direction,\n                    });\n                }\n            })\n            .on(\"move\", ({ offsetX, offsetY, inputEvent }) => {\n                const gesto = this.gesto;\n\n                if (!gesto || !gesto.isFlag()) {\n                    return;\n                }\n\n                const data = this.gesto.getEventData();\n                const boundArea = data.boundArea;\n\n                data.startX -= offsetX;\n                data.startY -= offsetY;\n\n                const innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n                const container = innerScrollOptions?.container;\n                let isMoveInnerScroll = false;\n\n                if (container) {\n                    const parentMap: Map<Element, InnerParentInfo> = data.selectableInnerScrollParentMap;\n                    const parentInfo = parentMap.get(container);\n\n                    if (parentInfo) {\n                        parentInfo.paths.forEach(scrollContainer => {\n                            const containerInfo = parentMap.get(scrollContainer);\n\n                            containerInfo.points.forEach(pos => {\n                                pos[0] -= offsetX;\n                                pos[1] -= offsetY;\n                            });\n                        });\n                        parentInfo.indexes.forEach(index => {\n                            data.selectablePoints[index].forEach((pos) => {\n                                pos[0] -= offsetX;\n                                pos[1] -= offsetY;\n                            });\n                        });\n                        isMoveInnerScroll = true;\n                    }\n                }\n                if (!isMoveInnerScroll) {\n                    data.selectablePoints.forEach((points: number[][]) => {\n                        points.forEach((pos) => {\n                            pos[0] -= offsetX;\n                            pos[1] -= offsetY;\n                        });\n                    });\n                }\n                this._refreshGroups(data);\n\n                boundArea.left -= offsetX;\n                boundArea.right -= offsetX;\n                boundArea.top -= offsetY;\n                boundArea.bottom -= offsetY;\n\n                this.gesto.scrollBy(\n                    offsetX,\n                    offsetY,\n                    inputEvent.inputEvent,\n                    // false\n                );\n                this._checkSelected(this.gesto.getCurrentEvent());\n            });\n    }\n    private _select(\n        selectedTargets: ElementType[],\n        rect: Rect,\n        e: OnDragEvent,\n        isStart?: boolean,\n        isDragStartEnd = false,\n    ) {\n        const inputEvent = e.inputEvent;\n        const data = e.data;\n        const result = this.setSelectedTargets(selectedTargets);\n        const { added, removed, prevList, list } = diff(\n            data.startSelectedTargets,\n            selectedTargets,\n        );\n\n        const startResult = {\n            startSelected: prevList,\n            startAdded: added.map(i => list[i]),\n            startRemoved: removed.map(i => prevList[i]),\n        };\n\n\n        if (isStart) {\n            /**\n             * When the select(drag) starts, the selectStart event is called.\n             * @memberof Selecto\n             * @event selectStart\n             * @param {Selecto.OnSelect} - Parameters for the selectStart event\n             * @example\n             * import Selecto from \"selecto\";\n             *\n             * const selecto = new Selecto({\n             *   container: document.body,\n             *   selectByClick: true,\n             *   selectFromInside: false,\n             * });\n             *\n             * selecto.on(\"selectStart\", e => {\n             *   e.added.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.removed.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * }).on(\"selectEnd\", e => {\n             *   e.afterAdded.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.afterRemoved.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * });\n             */\n            this.emit(\"selectStart\", {\n                ...result,\n                ...startResult,\n                rect,\n                inputEvent,\n                data: data.data,\n                isTrusted: e.isTrusted,\n                isDragStartEnd,\n            });\n        }\n        if (result.added.length || result.removed.length) {\n            /**\n             * When the select in real time, the select event is called.\n             * @memberof Selecto\n             * @event select\n             * @param {Selecto.OnSelect} - Parameters for the select event\n             * @example\n             * import Selecto from \"selecto\";\n             *\n             * const selecto = new Selecto({\n             *   container: document.body,\n             *   selectByClick: true,\n             *   selectFromInside: false,\n             * });\n             *\n             * selecto.on(\"select\", e => {\n             *   e.added.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.removed.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * });\n             */\n            this.emit(\"select\", {\n                ...result,\n                ...startResult,\n                rect,\n                inputEvent,\n                data: data.data,\n                isTrusted: e.isTrusted,\n                isDragStartEnd,\n            });\n        }\n    }\n    private _selectEnd(\n        startSelectedTargets: ElementType[],\n        startPassedTargets: ElementType[],\n        rect: Rect,\n        e: OnDragEvent,\n        isDragStartEnd: boolean = false,\n    ) {\n        const { inputEvent, isDouble, data } = e;\n        const type = inputEvent && inputEvent.type;\n        const isDragStart = type === \"mousedown\" || type === \"touchstart\";\n\n        const { added, removed, prevList, list } = diff(\n            startSelectedTargets,\n            this.selectedTargets\n        );\n        const {\n            added: afterAdded,\n            removed: afterRemoved,\n            prevList: afterPrevList,\n            list: afterList,\n        } = diff(startPassedTargets, this.selectedTargets);\n\n        /**\n         * When the select(dragEnd or click) ends, the selectEnd event is called.\n         * @memberof Selecto\n         * @event selectEnd\n         * @param {Selecto.OnSelectEnd} - Parameters for the selectEnd event\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   selectByClick: true,\n         *   selectFromInside: false,\n         * });\n         *\n         * selecto.on(\"selectStart\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * }).on(\"selectEnd\", e => {\n         *   e.afterAdded.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.afterRemoved.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        this.emit(\"selectEnd\", {\n            startSelected: startSelectedTargets,\n            beforeSelected: startPassedTargets,\n            selected: this.selectedTargets,\n            added: added.map((index) => list[index]),\n            removed: removed.map((index) => prevList[index]),\n            afterAdded: afterAdded.map((index) => afterList[index]),\n            afterRemoved: afterRemoved.map((index) => afterPrevList[index]),\n            isDragStart: isDragStart && isDragStartEnd,\n            isDragStartEnd: isDragStart && isDragStartEnd,\n            isClick: !!e.isClick,\n            isDouble: !!isDouble,\n            rect,\n            inputEvent,\n            data: data.data,\n            isTrusted: e.isTrusted,\n        });\n    }\n    private _onDragStart = (e: OnDragStart<Gesto>, clickedTarget?: Element) => {\n        const { data, clientX, clientY, inputEvent } = e;\n        const {\n            selectFromInside,\n            selectByClick,\n            rootContainer,\n            boundContainer,\n            preventDragFromInside = true,\n            clickBySelectEnd,\n            dragCondition,\n        } = this.options;\n\n        if (dragCondition && !dragCondition(e)) {\n            e.stop();\n            return;\n        }\n        data.data = {};\n        const win = getWindow(this.container);\n        data.innerWidth = win.innerWidth;\n        data.innerHeight = win.innerHeight;\n        this.findSelectableTargets(data);\n        data.startSelectedTargets = this.selectedTargets;\n        data.scaleMatrix = createMatrix();\n        data.containerX = 0;\n        data.containerY = 0;\n\n\n        const container = this.container;\n        let boundArea = {\n            left: -Infinity,\n            top: -Infinity,\n            right: Infinity,\n            bottom: Infinity,\n        };\n        if (rootContainer) {\n            const containerRect = this.container.getBoundingClientRect();\n\n            data.containerX = containerRect.left;\n            data.containerY = containerRect.top;\n            data.scaleMatrix = getDistElementMatrix(this.container, rootContainer);\n        }\n\n        if (boundContainer) {\n            const boundInfo: Required<BoundContainer> =\n                isObject(boundContainer) && \"element\" in boundContainer\n                    ? {\n                        left: true,\n                        top: true,\n                        bottom: true,\n                        right: true,\n                        ...boundContainer,\n                    }\n                    : {\n                        element: boundContainer,\n                        left: true,\n                        top: true,\n                        bottom: true,\n                        right: true,\n                    };\n            const boundElement = boundInfo.element;\n            let rectElement: HTMLElement;\n\n            if (boundElement) {\n                if (isString(boundElement)) {\n                    rectElement = getDocument(container).querySelector(boundElement);\n                } else if (boundElement === true) {\n                    rectElement = this.container;\n                } else {\n                    rectElement = boundElement;\n                }\n                const rect = rectElement.getBoundingClientRect();\n\n                if (boundInfo.left) {\n                    boundArea.left = rect.left;\n                }\n                if (boundInfo.top) {\n                    boundArea.top = rect.top;\n                }\n                if (boundInfo.right) {\n                    boundArea.right = rect.right;\n                }\n                if (boundInfo.bottom) {\n                    boundArea.bottom = rect.bottom;\n                }\n            }\n        }\n\n        data.boundArea = boundArea;\n\n        const hitRect = {\n            left: clientX,\n            top: clientY,\n            right: clientX,\n            bottom: clientY,\n            width: 0,\n            height: 0,\n        };\n        let firstPassedTargets: ElementType[] = [];\n\n        // allow click on select\n        const allowClickBySelectEnd = selectByClick && !clickBySelectEnd;\n        let hasInsideTargets = false;\n\n        if (!selectFromInside || allowClickBySelectEnd) {\n            const pointTarget = this._findElement(\n                clickedTarget || inputEvent.target, // elementFromPoint(clientX, clientY),\n                data.selectableTargets,\n            );\n\n            hasInsideTargets = !!pointTarget;\n            if (allowClickBySelectEnd) {\n                firstPassedTargets = pointTarget ? [pointTarget] : [];\n            }\n        }\n        const isPreventSelect = !selectFromInside && hasInsideTargets;\n\n        // prevent drag from inside when selectByClick is false\n        if (isPreventSelect && !selectByClick) {\n            e.stop();\n            return false;\n        }\n\n        const type = inputEvent.type;\n        const isTrusted = type === \"mousedown\" || type === \"touchstart\";\n        /**\n         * When the drag starts (triggers on mousedown or touchstart), the dragStart event is called.\n         * Call the stop () function if you have a specific element or don't want to raise a select\n         * @memberof Selecto\n         * @event dragStart\n         * @param {OnDragStart} - Parameters for the dragStart event\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   selectByClick: true,\n         *   selectFromInside: false,\n         * });\n         *\n         * selecto.on(\"dragStart\", e => {\n         *   if (e.inputEvent.target.tagName === \"SPAN\") {\n         *     e.stop();\n         *   }\n         * }).on(\"select\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        const result =\n            !(e).isClick && isTrusted\n                ? this.emit(\"dragStart\", { ...e, data: data.data })\n                : true;\n\n        if (!result) {\n            e.stop();\n            return false;\n        }\n\n        if (this.continueSelect) {\n            firstPassedTargets = passTargets(\n                this.selectedTargets,\n                firstPassedTargets,\n                this.continueSelectWithoutDeselect,\n            );\n            data.startPassedTargets = this.selectedTargets;\n        } else {\n            data.startPassedTargets = [];\n        }\n\n        this._select(\n            firstPassedTargets,\n            hitRect,\n            e,\n            true,\n            isPreventSelect && selectByClick && !clickBySelectEnd && preventDragFromInside,\n        );\n        data.startX = clientX;\n        data.startY = clientY;\n        data.selectFlag = false;\n        data.preventDragFromInside = false;\n\n        if (inputEvent.target) {\n            const offsetPos = calculateMatrixDist(data.scaleMatrix, [\n                clientX - data.containerX,\n                clientY - data.containerY,\n            ]);\n            this.target.style.cssText += `position: ${rootContainer ? \"absolute\" : \"fixed\"};`\n                + `left:0px;top:0px;`\n                + `transform: translate(${offsetPos[0]}px, ${offsetPos[1]}px)`;\n        }\n\n        if (isPreventSelect && selectByClick && !clickBySelectEnd) {\n            inputEvent.preventDefault();\n\n            // prevent drag from inside when selectByClick is true and force call `selectEnd`\n            if (preventDragFromInside) {\n                this._selectEnd(\n                    data.startSelectedTargets,\n                    data.startPassedTargets,\n                    hitRect,\n                    e,\n                    true,\n                );\n                data.preventDragFromInside = true;\n            }\n        } else {\n            data.selectFlag = true;\n            // why?\n            // if (type === \"touchstart\") {\n            //     inputEvent.preventDefault();\n            // }\n            const { scrollOptions, innerScrollOptions } = this.options;\n\n            let isInnerScroll = false\n\n            if (innerScrollOptions) {\n                const inputEvent = e.inputEvent;\n                const target = inputEvent.target;\n\n                let innerScrollElement: HTMLElement | null = null;\n                let parentElement = target;\n\n                while (parentElement && parentElement !== getDocument(container).body) {\n\n                    const overflow = getComputedStyle(parentElement).overflow !== \"visible\";\n\n                    if (overflow) {\n                        innerScrollElement = parentElement;\n                        break;\n                    }\n                    parentElement = parentElement.parentElement;\n                }\n                if (innerScrollElement) {\n                    data.innerScrollOptions = {\n                        container: innerScrollElement,\n                        checkScrollEvent: true,\n                        ...(innerScrollOptions === true ? {} : innerScrollOptions),\n                    };\n                    this.dragScroll.dragStart(e, data.innerScrollOptions);\n\n                    isInnerScroll = true;\n                }\n            }\n            if (!isInnerScroll && scrollOptions && scrollOptions.container) {\n                this.dragScroll.dragStart(e, scrollOptions);\n            }\n\n            if (isPreventSelect && selectByClick && clickBySelectEnd) {\n                data.selectFlag = false;\n                e.preventDrag();\n            }\n        }\n        return true;\n    };\n    private _checkSelected(e: any, rect = getRect(e, this.options.ratio)) {\n        const { data } = e;\n        const { top, left, width, height } = rect;\n        const selectFlag = data.selectFlag;\n        const {\n            containerX,\n            containerY,\n            scaleMatrix,\n        } = data;\n        const offsetPos = calculateMatrixDist(scaleMatrix, [\n            left - containerX,\n            top - containerY,\n        ]);\n        const offsetSize = calculateMatrixDist(scaleMatrix, [\n            width,\n            height,\n        ]);\n        let selectedTargets: ElementType[] = [];\n        if (selectFlag) {\n            this.target.style.cssText +=\n                `display: block;` +\n                `left:0px;top:0px;` +\n                `transform: translate(${offsetPos[0]}px, ${offsetPos[1]}px);` +\n                `width:${offsetSize[0]}px;height:${offsetSize[1]}px;`;\n\n            const passedTargets = this.hitTest(\n                rect,\n                data,\n                true,\n                e,\n            );\n            selectedTargets = passTargets(\n                data.startPassedTargets,\n                passedTargets,\n                this.continueSelect && this.continueSelectWithoutDeselect,\n            );\n        }\n        /**\n         * When the drag, the drag event is called.\n         * Call the stop () function if you have a specific element or don't want to raise a select\n         * @memberof Selecto\n         * @event drag\n         * @param {OnDrag} - Parameters for the drag event\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   selectByClick: true,\n         *   selectFromInside: false,\n         * });\n         *\n         * selecto.on(\"drag\", e => {\n         *   e.stop();\n         * }).on(\"select\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        const result = this.emit(\"drag\", {\n            ...e,\n            data: data.data,\n            isSelect: selectFlag,\n            rect,\n        });\n        if (result === false) {\n            this.target.style.cssText += \"display: none;\";\n            e.stop();\n            return;\n        }\n\n        if (selectFlag) {\n            this._select(selectedTargets, rect, e);\n        }\n    }\n    private _onDrag = (e: OnDrag) => {\n        if (e.data.selectFlag) {\n            const scrollOptions = this.scrollOptions;\n            const innerScrollOptions = e.data.innerScrollOptions;\n            const hasScrollOptions = innerScrollOptions || scrollOptions?.container;\n\n            // If it is a scrolling position, pass drag\n            if (hasScrollOptions && !e.isScroll && this.dragScroll.drag(e, innerScrollOptions || scrollOptions)) {\n                return;\n            }\n        }\n        this._checkSelected(e);\n    };\n    private _onDragEnd = (e: OnDragEvent) => {\n        const { data, inputEvent } = e;\n        const rect = getRect(e, this.options.ratio);\n        const selectFlag = data.selectFlag;\n        const container = this.container;\n\n        /**\n         * When the drag ends (triggers on mouseup or touchend after drag), the dragEnd event is called.\n         * @memberof Selecto\n         * @event dragEnd\n         * @param {OnDragEnd} - Parameters for the dragEnd event\n         */\n        if (inputEvent) {\n            this.emit(\"dragEnd\", {\n                isDouble: !!e.isDouble,\n                isClick: !!e.isClick,\n                isDrag: false,\n                isSelect: selectFlag,\n                ...e,\n                data: data.data,\n                rect,\n            });\n        }\n        this.target.style.cssText += \"display: none;\";\n\n        if (selectFlag) {\n            data.selectFlag = false;\n            this.dragScroll.dragEnd();\n        } else if (this.selectByClick && this.clickBySelectEnd) {\n            // only clickBySelectEnd\n            const pointTarget = this._findElement(\n                inputEvent?.target || elementFromPoint(container, e.clientX, e.clientY),\n                data.selectableTargets,\n            );\n            this._select(pointTarget ? [pointTarget] : [], rect, e);\n        }\n        if (!data.preventDragFromInside) {\n            this._selectEnd(\n                data.startSelectedTargets,\n                data.startPassedTargets,\n                rect,\n                e\n            );\n        }\n    };\n    private _sameCombiKey(e: any, keys: string | string[] | string[][], isKeyup?: boolean) {\n        if (!keys) {\n            return false;\n        }\n        const combi = getCombi(e.inputEvent, e.key);\n        const nextKeys = [].concat(keys);\n        const toggleKeys = isArray(nextKeys[0]) ? nextKeys : [nextKeys];\n\n        if (isKeyup) {\n            const singleKey = e.key;\n\n            return toggleKeys.some((keys) =>\n                keys.some((key: string) => key === singleKey)\n            );\n        }\n        return toggleKeys.some((keys) =>\n            keys.every((key: string) => combi.indexOf(key) > -1)\n        );\n    }\n    private _onKeyDown = (e: KeyControllerEvent) => {\n        const options = this.options;\n        let isKeyDown = false;\n\n        if (!this._keydownContinueSelect) {\n            const result = this._sameCombiKey(e, options.toggleContinueSelect);\n\n            this._keydownContinueSelect = result;\n            isKeyDown ||= result;\n        }\n        if (!this._keydownContinueSelectWithoutDeselection) {\n            const result = this._sameCombiKey(e, options.toggleContinueSelectWithoutDeselect);\n\n            this._keydownContinueSelectWithoutDeselection = result;\n            isKeyDown ||= result;\n        }\n        if (!isKeyDown) {\n            return;\n        }\n        /**\n         * When you keydown the key you specified in toggleContinueSelect, the keydown event is called.\n         * @memberof Selecto\n         * @event keydown\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   toggleContinueSelect: \"shift\";\n         *   keyContainer: window,\n         * });\n         *\n         * selecto.on(\"keydown\", () => {\n         *   document.querySelector(\".button\").classList.add(\"selected\");\n         * }).on(\"keyup\", () => {\n         *   document.querySelector(\".button\").classList.remove(\"selected\");\n         * }).on(\"select\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        this.emit(\"keydown\", {\n            keydownContinueSelect: this._keydownContinueSelect,\n            keydownContinueSelectWithoutDeselection: this._keydownContinueSelectWithoutDeselection,\n        });\n    };\n    private _onKeyUp = (e: KeyControllerEvent) => {\n        const options = this.options;\n        let isKeyUp = false;\n\n        if (this._keydownContinueSelect) {\n            const result = this._sameCombiKey(e, options.toggleContinueSelect, true);\n            this._keydownContinueSelect = !result;\n\n            isKeyUp ||= result;\n        }\n        if (this._keydownContinueSelectWithoutDeselection) {\n            const result = this._sameCombiKey(e, options.toggleContinueSelectWithoutDeselect, true);\n            this._keydownContinueSelectWithoutDeselection = !result;\n\n            isKeyUp ||= result;\n        }\n        if (!isKeyUp) {\n            return;\n        }\n\n        /**\n         * When you keyup the key you specified in toggleContinueSelect, the keyup event is called.\n         * @memberof Selecto\n         * @event keyup\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   toggleContinueSelect: \"shift\";\n         *   keyContainer: window,\n         * });\n         *\n         * selecto.on(\"keydown\", () => {\n         *   document.querySelector(\".button\").classList.add(\"selected\");\n         * }).on(\"keyup\", () => {\n         *   document.querySelector(\".button\").classList.remove(\"selected\");\n         * }).on(\"select\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        this.emit(\"keyup\", {\n            keydownContinueSelect: this._keydownContinueSelect,\n            keydownContinueSelectWithoutDeselection: this._keydownContinueSelectWithoutDeselection,\n        });\n    };\n    private _onBlur = () => {\n        if (this._keydownContinueSelect || this._keydownContinueSelectWithoutDeselection) {\n            this._keydownContinueSelect = false;\n            this._keydownContinueSelectWithoutDeselection = false;\n            this.emit(\"keyup\", {\n                keydownContinueSelect: this._keydownContinueSelect,\n                keydownContinueSelectWithoutDeselection: this._keydownContinueSelectWithoutDeselection,\n            });\n        }\n    };\n    private _onDocumentSelectStart = (e: any) => {\n        const doc = getDocument(this.container);\n\n        if (!this.gesto.isFlag()) {\n            return;\n        }\n        let dragContainer = this.dragContainer;\n\n        if (dragContainer === getWindow(this.container)) {\n            dragContainer = doc.documentElement;\n        }\n        const containers = isNode(dragContainer)\n            ? [dragContainer]\n            : ([].slice.call(dragContainer) as Element[]);\n        const target = e.target;\n\n        containers.some((container) => {\n            if (container === target || container.contains(target)) {\n                e.preventDefault();\n                return true;\n            }\n        });\n    };\n    private _findElement(clickedTarget: ElementType, selectableTargets: Element[]) {\n        let pointTarget = clickedTarget;\n\n        while (pointTarget) {\n            if (selectableTargets.indexOf(pointTarget) > -1) {\n                break;\n            }\n            pointTarget = pointTarget.parentElement;\n        }\n        return pointTarget;\n    }\n    private _refreshGroups(data: IObject<any>) {\n        const innerWidth = data.innerWidth;\n        const innerHeight = data.innerHeight;\n        const selectablePoints: number[][][] = data.selectablePoints;\n\n        if (this.options.checkOverflow) {\n            const innerScrollContainer = this.gesto.getEventData().innerScrollOptions?.container;\n            const parentMap: Map<Element, InnerParentInfo> = data.selectableInnerScrollParentMap;\n            const innerScrollPathsList: Element[][] = data.selectableInnerScrollPathsList;\n\n            data.selectableInners = innerScrollPathsList.map((innerScrollPaths, i) => {\n                let isAlwaysTrue = false;\n                return innerScrollPaths.every(target => {\n                    if (isAlwaysTrue) {\n                        return true;\n                    }\n                    if (target === innerScrollContainer) {\n                        isAlwaysTrue = true;\n                        return true;\n                    }\n\n                    const rect = parentMap.get(target);\n\n                    if (rect) {\n                        const points1 = selectablePoints[i];\n                        const points2 = rect.points;\n                        const overlapPoints = getOverlapPoints(points1, points2);\n\n                        if (!overlapPoints.length) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            });\n        }\n        if (!innerWidth || !innerHeight) {\n            data.innerGroups = null;\n        } else {\n            const selectablePoints: number[][][] = data.selectablePoints;\n\n            const groups: Record<string | number, Record<string | number, number[]>> = {};\n\n            selectablePoints.forEach((points, i) => {\n                let minX = Infinity;\n                let maxX = -Infinity;\n                let minY = Infinity;\n                let maxY = -Infinity;\n\n                points.forEach(pos => {\n                    const x = Math.floor(pos[0] / innerWidth);\n                    const y = Math.floor(pos[1] / innerHeight);\n\n                    minX = Math.min(x, minX);\n                    maxX = Math.max(x, maxX);\n                    minY = Math.min(y, minY);\n                    maxY = Math.max(y, maxY);\n                });\n\n                for (let x = minX; x <= maxX; ++x) {\n                    for (let y = minY; y <= maxY; ++y) {\n                        groups[x] = groups[x] || {};\n                        groups[x][y] = groups[x][y] || [];\n\n                        groups[x][y].push(i);\n                    }\n                }\n            });\n\n            data.innerGroups = groups;\n        }\n    }\n}\n\ninterface Selecto extends SelectoProperties { }\n\nexport default Selecto;\n", "import SelectoManager from \"./SelectoManager\";\n\nclass Selecto extends SelectoManager {\n\n}\nexport default Selecto;\n", "import { EVENTS } from \"selecto\";\nimport { camelize } from \"@daybrush/utils\";\n\nexport const REACT_EVENTS =  EVENTS.map(name => camelize(`on ${name}`));\n", "import * as React from \"react\";\nimport VanillaSelecto, {\n    CLASS_NAME,\n    OPTIONS,\n    SelectoOptions,\n    PROPERTIES,\n    SelectoProperties,\n    EVENTS,\n    SelectoMethods,\n    METHODS,\n} from \"selecto\";\nimport { ref, MethodInterface, withMethods } from \"framework-utils\";\nimport { SelectoProps } from \"./types\";\nimport { REACT_EVENTS } from \"./consts\";\n\nexport default class Selecto extends React.PureComponent<Partial<SelectoProps>> {\n    @withMethods(METHODS as any)\n    private selecto!: VanillaSelecto;\n    private selectionElement!: HTMLElement;\n    public render() {\n        return <div className={CLASS_NAME} ref={ref(this, \"selectionElement\")}></div>;\n    }\n    public componentDidMount() {\n        const props = this.props;\n        const options: Partial<SelectoOptions> = {};\n\n        OPTIONS.forEach(name => {\n            if (name in props) {\n                (options as any)[name] = props[name];\n            }\n        });\n        this.selecto = new VanillaSelecto({\n            ...options,\n            portalContainer: this.selectionElement,\n        });\n\n        EVENTS.forEach((name, i) => {\n            this.selecto.on(name, (e: any) => {\n                const selfProps = this.props as any;\n                const result = selfProps[REACT_EVENTS[i]] && selfProps[REACT_EVENTS[i]](e);\n\n                if (result === false) {\n                    e.stop();\n                }\n            });\n        });\n    }\n    public componentDidUpdate(prevProps: Partial<SelectoProperties>) {\n        const props = this.props;\n        const selecto = this.selecto;\n\n        PROPERTIES.forEach(name => {\n            if (prevProps[name] !== props[name]) {\n                (selecto as any)[name] = props[name];\n            }\n        });\n    }\n    public componentWillUnmount() {\n        this.selecto.destroy();\n    }\n}\nexport default interface Selecto extends MethodInterface<SelectoMethods, VanillaSelecto, Selecto> {}\n"],
  "mappings": "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",
  "names": ["FUNCTION", "OBJECT", "STRING", "UNDEFINED", "IS_WINDOW", "window", "doc", "document", "prefixes", "getCrossBrowserProperty", "property", "styles", "body", "documentElement", "style", "length", "i", "name", "TRANSFORM", "FILTER", "ANIMATION", "KEYFRAMES", "replace", "OPEN_CLOSED_CHARACTERS", "open", "close", "TINY_NUM", "REVERSE_TINY_NUM", "DEFAULT_UNIT_PRESETS", "pos", "size", "innerWidth", "innerHeight", "Math", "max", "min", "isObject", "value", "OBJECT", "isArray", "Array", "isString", "STRING", "isFunction", "value", "FUNCTION", "isEqualSeparator", "character", "separator", "isCharacterSpace", "isSeparatorSpace", "findOpen", "openCharacter", "texts", "index", "length", "openCloseCharacters", "isIgnore", "findIgnore", "findClose", "ignore", "otherText", "slice", "Math", "max", "join", "RegExp", "exec", "closeCharacter", "i", "trim", "close", "nextIndex", "find", "_a", "open", "splitText", "text", "splitOptions", "isString", "_b", "isSeparateFirst", "isSeparateOnlyOpenClose", "_c", "isSeparateOpenClose", "_d", "OPEN_CLOSED_CHARACTERS", "openClosedText", "map", "regexText", "regex", "split", "filter", "chr", "values", "tempValues", "resetTemp", "push", "nextOpenCloseCharacters", "splice", "indexOf", "splitSpace", "splitComma", "splitBracket", "matches", "prefix", "suffix", "splitUnit", "unit", "NaN", "parseFloat", "camelize", "str", "replace", "all", "letter", "toUpperCase", "now", "Date", "getTime", "findIndex", "arr", "callback", "defaultIndex", "length", "i", "find", "arr", "callback", "defalutValue", "index", "findIndex", "requestAnimationFrame", "firstTime", "now", "raf", "IS_WINDOW", "window", "webkitRequestAnimationFrame", "mozRequestAnimationFrame", "msRequestAnimationFrame", "bind", "currTime", "id", "setTimeout", "cancelAnimationFrame", "caf", "webkitCancelAnimationFrame", "mozCancelAnimationFrame", "msCancelAnimationFrame", "handle", "clearTimeout", "convertUnitSize", "pos", "size", "_a", "splitUnit", "value", "unit", "isObject", "sizeFunction", "isFunction", "DEFAULT_UNIT_PRESETS", "between", "min", "max", "Math", "checkBoundSize", "targetSize", "compareSize", "isMax", "ratio", "throttle", "TINY_NUM", "filter", "every", "i", "defaultSize", "throttledSize", "calculateBoundSize", "minSize", "maxSize", "keepRatio", "map", "width", "height", "minWidth", "minHeight", "_b", "maxWidth", "maxHeight", "sum", "nums", "length", "total", "average", "getRad", "pos1", "pos2", "distX", "distY", "rad", "atan2", "PI", "getCenterPoint", "points", "getShapeDirection", "center", "pos1Rad", "pos2Rad", "getDist", "a", "b", "sqrt", "pow", "num", "reverseUnit", "round", "hasClass", "element", "className", "classList", "contains", "match", "RegExp", "addClass", "add", "addEvent", "el", "type", "listener", "options", "addEventListener", "removeEvent", "removeEventListener", "getDocument", "ownerDocument", "document", "getWindow", "el", "ownerDocument", "defaultView", "window", "isWindow", "val", "isNode", "isObject", "nodeName", "nodeType", "EventEmitter", "eventName", "listener", "isObject", "name", "on", "_addEvent", "_events", "off", "events", "index", "findIndex", "e", "splice", "once", "Promise", "resolve", "_this", "param", "isStop", "eventType", "stop", "currentTarget", "__spreadArrays", "forEach", "info", "emit", "options", "listeners", "push", "d", "b", "__assign", "getRad", "getDist", "ClientStore", "Gesto", "_a", "container", "options", "ref", "target", "name", "e", "Properties", "properties", "action", "component", "prototype", "forEach", "property", "withMethods", "methods", "duplicate", "propertyName", "name", "methodName", "_i", "args", "result", "_a", "key", "values", "keys", "indexOf", "value", "prevIndex", "index", "length", "object", "SUPPORT_MAP", "Map", "prevLink", "nextLink", "prev", "next", "link", "orderChanged", "changed", "fixed", "fromLinks", "toLinks", "forEach", "_a", "from", "to", "Link", "i", "connect", "filter", "_", "map", "fromLink", "toLink", "fromIndex", "getIndex", "disconnect", "undefined", "toIndex", "prevList", "list", "added", "removed", "maintained", "changedBeforeAdded", "Object", "cacheOrdered", "caculateOrdered", "cachePureChanged", "ordered", "pureChanged", "_b", "fromBefore", "toBefore", "push", "diff", "findKeyCallback", "mapClass", "HashMap", "PolyMap", "callback", "e", "prevKeys", "prevKeyMap", "keyMap", "removedMap", "addedCount", "removedCount", "prevListIndex", "set", "listIndex", "get", "reverse", "Result", "slice", "call", "newData", "result", "findKeyCallback", "Map", "undefined", "childrenCount", "el", "__DIFF_KEY__", "tslib_1", "ChildrenDiffer", "list", "_super", "ListDiffer", "diff", "prevList", "listdiff", "getDefaultScrollPosition", "e", "container", "document", "body", "scrollLeft", "documentElement", "scrollTop", "checkDefaultScrollEvent", "callback", "addEventListener", "removeEventListener", "getContainerElement", "isString", "querySelector", "isFunction", "Element", "current", "value", "__extends", "DragScroll", "_this", "options", "_currentOptions", "_lock", "emit", "next", "inputEvent", "checkScroll", "_flag", "top", "left", "width", "height", "window", "innerWidth", "innerHeight", "rect", "getBoundingClientRect", "_startPos", "clientX", "clientY", "_startRect", "_prevScrollPos", "_getScrollPosition", "_registerScrollEvent", "clearTimeout", "_timer", "_a", "threshold", "_b", "direction", "_continueDrag", "__assign", "isDrag", "_isWait", "prevScrollPos", "throttleTime", "nextScrollPos", "offsetX", "offsetY", "nextDirection", "Math", "abs", "setTimeout", "_unregisterScrollEvent", "getScrollPosition", "useScroll", "nowTime", "now", "distTime", "max", "_prevTime", "param", "requestScroll", "checkScrollEvent", "_unregister", "_onScroll", "EventEmitter", "codeData", "keysSort", "shift", "ctrl", "alt", "meta", "getKey", "keyCode", "keyName", "key", "names", "toLowerCase", "name", "replace", "getCombi", "e", "keys", "getModifierCombi", "indexOf", "push", "filter", "Boolean", "shiftKey", "ctrlKey", "altKey", "metaKey", "getArrangeCombi", "arrangeKeys", "slice", "sort", "prev", "next", "prevScore", "nextScore", "globalKeyController", "__extends", "KeyController", "container", "_super", "_this", "triggerEvent", "clear", "trigger", "addEvent", "blur", "keydownEvent", "keyupEvent", "Object", "global", "off", "removeEvent", "comb", "callback", "type", "isArray", "on", "join", "isString", "isToggle", "param", "inputEvent", "combi", "length", "EventEmitter", "tinyThrottle", "num", "throttle", "TINY_NUM", "isSameConstants", "linearConstants1", "linearConstants2", "every", "v", "i", "isSamePoint", "point1", "point2", "getAreaSize", "points", "length", "Math", "abs", "sum", "map", "point", "i", "nextPoint", "fitPoints", "rect", "width", "height", "left", "top", "_a", "getMinMaxs", "minX", "minY", "maxX", "maxY", "ratioX", "ratioY", "xs", "ys", "min", "max", "isInside", "pos", "excludeLine", "x", "y", "xLine", "xLinearConstants", "getLinearConstants", "lines", "convertLines", "intersectionPosInfos", "forEach", "line", "linearConstants", "standardPoint", "isSameConstants", "push", "type", "xPoints", "getPointsOnLines", "getIntersectionPointsByConstants", "some", "linePoint", "isSamePoint", "tinyThrottle", "find", "p", "intersectionCount", "xMap", "prevValue", "nextValue", "getLinearConstants", "point1", "point2", "x1", "y1", "x2", "y2", "dx", "dy", "Math", "abs", "TINY_NUM", "a", "b", "c", "getIntersectionPointsByConstants", "linearConstants1", "linearConstants2", "a1", "b1", "c1", "a2", "b2", "c2", "isZeroA", "isZeroB", "results", "Infinity", "y", "x", "map", "result", "getPointsOnLines", "points", "lines", "minMaxs", "map", "line", "order", "Math", "min", "max", "results", "length", "_a", "x", "y", "tinyThrottle", "top", "minMax", "bottom", "left", "right", "filter", "point", "pointX", "pointY", "every", "result", "convertLines", "__spreadArrays", "slice", "i", "getOverlapPointInfos", "points1", "points2", "targetPoints1", "targetPoints2", "getShapeDirection", "reverse", "lines1", "lines2", "linearConstantsList1", "line1", "getLinearConstants", "linearConstantsList2", "line2", "overlapInfos", "forEach", "linearConstants1", "linePointInfos", "linearConstants2", "j", "intersectionPoints", "getIntersectionPointsByConstants", "push", "pos", "index1", "index2", "type", "sort", "a", "b", "getDist", "isInside", "isNext", "index", "findIndex", "splice", "pointMap", "key", "getOverlapPoints", "infos", "add", "matrix", "inverseMatrix", "startIndex", "fromIndex", "n", "k", "i", "x", "fromX", "swap", "v", "iv", "divide", "invert", "matrix", "n", "Math", "sqrt", "length", "newMatrix", "slice", "inverseMatrix", "createIdentityMatrix", "i", "identityIndex", "throttle", "TINY_NUM", "j", "swap", "divide", "targetStartIndex", "targetIndex", "target", "add", "multiply", "matrix", "matrix2", "n", "Math", "sqrt", "length", "newMatrix", "m", "k", "i", "j", "l", "calculate", "matrix", "matrix2", "n", "length", "result", "multiply", "k", "map", "v", "rotateX3d", "rad", "Math", "cos", "sin", "rotateY3d", "rotateZ3d", "createRotateMatrix", "scale3d", "_a", "_b", "sx", "_c", "sy", "_d", "sz", "translate3d", "matrix", "_a", "_b", "tx", "_c", "ty", "_d", "tz", "multiply", "matrix3d", "matrix1", "matrix2", "createRotateMatrix", "rad", "n", "cos", "Math", "sin", "m", "createIdentityMatrix", "length", "i", "__assign", "__assign", "getHash", "str", "stringHash", "toString", "getShadowRoot", "parentElement", "getRootNode", "rootNode", "nodeType", "replaceStyle", "className", "css", "options", "original", "replace", "_", "selector", "trimmedSelector", "trim", "splitComma", "map", "subSelector", "trimmedSubSelector", "indexOf", "join", "injectStyle", "el", "shadowRoot", "doc", "getDocument", "style", "createElement", "setAttribute", "nonce", "innerHTML", "head", "body", "appendChild", "styled", "injectClassName", "inject", "styleElement", "ownerDocument", "document", "querySelector", "count", "parseFloat", "getAttribute", "destroy", "injectCount", "remove", "parentNode", "removeChild", "getClient", "e", "touch", "touches", "changedTouches", "clientX", "clientY", "filterDuplicated", "arr", "Map", "filter", "value", "index", "indexOf", "map", "has", "set", "elementFromPoint", "baseNode", "doc", "getDocument", "createElement", "jsx", "prevTarget", "container", "tag", "children", "attributes", "className", "style", "el", "name", "setAttribute", "elChildren", "forEach", "child", "i", "split", "hasClass", "addClass", "elStyle", "appendChild", "h", "attrs", "_i", "_a", "_b", "_c", "diffValue", "prev", "cur", "func", "getRect", "ratio", "boundArea", "data", "distX", "distY", "_d", "startX", "startY", "nextHeight", "Math", "sqrt", "nextWidth", "width", "abs", "height", "maxWidth", "left", "right", "maxHeight", "top", "bottom", "calculateBoundSize", "tx", "min", "ty", "getDefaultElementRect", "rect", "getBoundingClientRect", "pos1", "pos2", "pos3", "pos4", "passTargets", "beforeTargets", "afterTargets", "continueSelectWithoutDeselect", "diff", "list", "prevList", "added", "removed", "maintained", "nextIndex", "getLineSize", "points", "size", "length", "max", "getDist", "injector", "styled", "CLASS_NAME", "PROPERTIES", "OPTIONS", "__spreadArray", "OPTION_TYPES", "String", "boundContainer", "portalContainer", "dragContainer", "selectableTargets", "Array", "selectByClick", "Boolean", "selectFromInside", "continueSelect", "toggleContinueSelect", "toggleContinueSelectWithoutDeselect", "keyContainer", "hitRate", "Number", "scrollOptions", "Object", "checkInput", "preventDefault", "cspNonce", "getElementRect", "Function", "preventDragFromInside", "rootContainer", "dragCondition", "clickBySelectEnd", "preventClickEventOnDragStart", "preventClickEventOnDrag", "checkOverflow", "innerScrollOptions", "EVENTS", "METHODS", "__extends", "Selecto", "options", "_super", "_this", "DragScroll", "clickedTarget", "inputEvent", "stop", "win", "getWindow", "innerWidth", "innerHeight", "findSelectableTargets", "startSelectedTargets", "selectedTargets", "scaleMatrix", "createMatrix", "containerX", "containerY", "Infinity", "containerRect", "getDistElementMatrix", "boundInfo", "isObject", "__assign", "element", "boundElement", "rectElement", "isString", "querySelector", "hitRect", "firstPassedTargets", "allowClickBySelectEnd", "hasInsideTargets", "pointTarget", "_findElement", "target", "isPreventSelect", "type", "isTrusted", "result", "isClick", "emit", "startPassedTargets", "_select", "selectFlag", "offsetPos", "calculateMatrixDist", "cssText", "_selectEnd", "isInnerScroll", "inputEvent_1", "innerScrollElement", "parentElement", "body", "overflow", "getComputedStyle", "checkScrollEvent", "dragScroll", "dragStart", "preventDrag", "hasScrollOptions", "isScroll", "drag", "_checkSelected", "isDouble", "isDrag", "isSelect", "dragEnd", "isKeyDown", "_keydownContinueSelect", "_sameCombiKey", "_keydownContinueSelectWithoutDeselection", "keydownContinueSelect", "keydownContinueSelectWithoutDeselection", "isKeyUp", "gesto", "isFlag", "documentElement", "containers", "isNode", "slice", "call", "some", "contains", "document", "initElement", "initDragScroll", "setKeyController", "beforeSelected", "selected", "point1", "point2", "ignoreClick", "selectedElements", "hitTest", "setSelectedTargets", "startPoint", "endPoint", "mousedown", "MouseEvent", "cancelable", "bubbles", "mousemove", "mouseup", "onDragStart", "onDrag", "onDragEnd", "triggerDragStart", "off", "keycon", "destroy", "unset", "injectResult", "removeEvent", "_onDocumentSelectStart", "removeChild", "info", "fitPoints", "selectableElements", "isFunction", "push", "current", "elements", "querySelectorAll", "getEventData", "checkScroll", "getCurrentEvent", "getSelectableElements", "selectablePoints", "getElementPoints", "selectableParentMap", "hasIndexesMap", "parentMap_1", "selectableInnerScrollParentMap", "selectableInnerScrollPathsList", "parents", "paths", "get", "indexes", "prevParentElement", "selectableInners", "_refreshGroups", "dragEvent", "_onDragStart", "_onDragEnd", "KeyController", "keydown", "_onKeyDown", "keyup", "_onKeyUp", "on", "_onBlur", "nextClassName", "setKeyEvent", "preventClickEventByCondition", "preventRightClick", "parentNode", "Gesto", "checkWindowBlur", "_onDrag", "addEvent", "inject", "nonce", "selectRect", "gestoEvent", "innerGroups", "rectPoints", "isHit", "hitRateValue", "splitUnit", "inArea", "isInside", "overlapPoints", "getOverlapPoints", "overlapSize", "getAreaSize", "targetSize", "unit", "rate", "between", "round", "_", "minX", "floor", "maxX", "minY", "maxY", "x", "yGroups", "y", "group", "inner", "next", "direction", "offsetX", "offsetY", "isMoveInnerScroll", "parentMap_2", "parentInfo", "scrollContainer", "containerInfo", "pos", "scrollBy", "isStart", "isDragStartEnd", "startResult", "startSelected", "startAdded", "startRemoved", "isDragStart", "afterAdded", "afterRemoved", "afterPrevList", "afterList", "offsetSize", "passedTargets", "keys", "isKeyup", "combi", "getCombi", "key", "nextKeys", "concat", "toggleKeys", "isArray", "singleKey_1", "every", "innerScrollContainer_1", "parentMap_3", "innerScrollPathsList", "innerScrollPaths", "isAlwaysTrue", "points1", "points2", "selectablePoints_1", "groups_1", "Properties", "prototype", "property", "enumerable", "configurable", "getter", "camelize", "setter", "defineProperty", "EventEmitter", "SelectoManager", "REACT_EVENTS", "EVENTS", "map", "name", "camelize", "Selecto", "__extends", "React", "className", "CLASS_NAME", "ref", "props", "options", "OPTIONS", "forEach", "selecto", "VanillaSelecto", "__assign", "portalContainer", "selectionElement", "i", "_this", "on", "e", "selfProps", "result", "stop", "prevProps", "PROPERTIES", "destroy", "__decorate", "withMethods", "METHODS"]
}
